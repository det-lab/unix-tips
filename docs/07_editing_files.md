# Editing Files with `sed` and `ed`
While graphical or full-screen editors like `nano`, `vim`, and `emacs` are interactive, Unix also provides **stream-based** and **line-based** editors that are ideal for scripting or batch processing. Two of the most powerful tools for this are `sed` and `ed`.
## Using `sed`
`sed` works by reading a file line-by-line and applying transformation rules, often in the form of substitutions, deletions, or insertions. It is especially useful for making changes to large files or automating repetitive edits.

The basic syntax of `sed` follows:
```bash
sed [OPTIONS] 'COMMANDS' filename
```
When replacing/substituting text using `sed`, the general format of the `'COMMAND'` should follow:
```bash
's/pattern/replacement/[flags]'
```
Here, `s` stands for substitute. This tells `sed` that the goal is to search and replace. The `pattern` can then be a word, regex, or a complex pattern. The `replacement` is then what you are telling `sed` to replace the `pattern` with. Finally, `[flags]` represents the optional modifiers:
| Flag       | Meaning                                 |
|:---        |  ---                                    |
|`g`         | Global - replace all matches            |
|`1,2,...`   | Replace only the nth match              |
|`p`         | Print only the substituted line         |
|`I`         | Ignore case while searching             |
|`e`         | Substitute and execute the command line |

If you don't use one of the `flags` (i.e 's/pattern/replacement/'), it will only replace the first match. You can also use multiple flags in conjunction with one another. For instance, if you wanted to go line by line and replace every instance of a pattern after the third, while also ignoring case, you could use the flag `3Ig`. For clarity: this would not go from the third in the file on, but from the third in the line on, resetting the counter with each new line. 

Let's take a look at how to use some of the more common `OPTIONS`:
### `-i[SUFFIX]`/`--in-place[SUFFIX]`
This is one of the more vital options, and will often be used alongside others. It allows you to edit files in place, and can also make a backup of the file before creating a change if given the optional `SUFFIX`. Without including `-i`, this option will simply print what the given lines *would* look like if they were edited.

Let's say we want to make an edit to our `planets.csv` file to have more explicit column names. Let's edit the title "Planets" to instead be "Planet Names" while also creating a `.bak` backup version of the file. `sed` can accomplish this with the expression:
```bash
sed -i.bak 's/Planet/Planet Name/' ./local-universe/milky-way/planets.csv
```
After running this, you will then have a new file named `planets.csv.bak` with the original version of the file, while the change "Planet" $\to$ "Planet Name" will be reflected in `planets.csv`.
>NOTE: It is not allowed to stack options after `-i`. Attempting to would simply result in the characters being appended to the end of the file. Multiple options can still be chosen or even stacked after `-i`, but must be separated with a space in order to not be treated as a suffix. 
### `-n`/`--quiet`/`--silent`
This option suppresses the automatic printing of duplicate rows which can be generated by other flags. If used with the `/p` flag, this option will print only the targeted lines. Let's say you want to preview an edit to `galaxies.csv` where it is more explicit with the column names, changing "Types" to "Galaxy Types". You could run:
```bash
sed -n 's/Type/Galaxy Type/p' ./local-universe/galaxies.csv
```
**Output:**
```bash
Galaxy, Constellation, Galaxy Type,
```
>NOTE: If you tried to add `-i` to this expression, it would result in a file that contains only the output line. To edit the line in the file, you would want to remove both `-n` and `/p`.
### `-e script`/`--expression=script`
These options allow for us to chain together multiple expressions. Let's say we want to convert the units of the planet radii from `m` to `km`. As the planets are all expressed with a radius of either $x \times 10^6$m (xE6) or $x \times 10^7$m (xE7), we could run the following three expressions to make this change:
```bash
sed -i -e 's/(m)/(km)/' -e 's/E6/E3/g' -e 's/E7/E4/g' ./local-universe/milky-way/planets.csv
```
### `-f script-file`/`--file=script-file`
Instead of using `-e`, we can instead create a script file to read commands. This can be useful for when the number of edits you're trying to make would be cumbersome to type out directly in the command line. Let's say we want to represent the mass of all of the planets in tons instead of kilograms (1000 Kg = 1T). We can create a file and fill it with the relevant replacement commands:
```bash
nano kilogram-replacement.txt
```
```bash
s/(Kg)/(T)/
s/E23/E20/g
s/E24/E21/g
s/E25/E22/g
s/E26/E23/g
s/E27/E24/g
```
We can then run the expression:
```bash
sed -i -f kilogram-replacement.txt ./local-universe/milky-way/planets.csv
```
### `-E`/`-r`/`--regexp-extended`
These allow for the use of extended regular expressions.
### `-s`/`--separate`
These allow for you to use **multiple** input files while also treating them as separate inputs. Without it, multiple input files can still be used, but will be treated as one longer stream.
```bash
sed -n -s '/Leo/p' ./local-universe/galaxies.csv ./local-universe/milky-way/constellations.csv
```
**Output:**
```bash
Leo A, Leo, Irregular
Leo, Regulus,
```
## Using `ed`
The `ed` line editor was one of the three original elements of the Unix system (assembler, editor, and shell), and can be used as a more surgical tool for editing files line-by-line. It's especially useful when you know or can find out the exact line numbers you wish to edit or when you want to script out precise edits. For most purposes however, `ed` is less useful than text-editors such as `nano` or `vim`, but it can be very efficient for specific uses with enough planning and forethought.

Editing with `ed` is accomplished in two distinct modes: **command** and **input**. 

Command mode is the default mode when `ed` is initially invoked. From here, commands are read from the standard input and executed to manipulate the contents of the file. All commands operate on whole lines or ranges of lines. 

You can then enter input mode by inputting a command, such as `a` (append), `i` (insert), `d` (delete), or `c` (change). No commands are available after entering input, and input mode can then be terminated by entering a single period (`.`) on its own line.

The format for running `ed` follows:
```ed
ed [OPTIONS] [[line] file]
ed [OPTIONS] [[line] '!command [arguments]']
```
>NOTE: If the given `file` starts with a `!`, then it is interpreted as a shell command, meaning it will read the standard output of the `file` as if it was executed via the shell. If the file's name begins with a `!` then (and doesn't contain commands you want to run), simply prefix the name with `./`. 
### Addressing Lines in `ed`
The file name can also be preceded by `line` to set the current line to a specified line number (such as `1`). This will default to the last line if the number given exceeds the number of lines in the file. It is also important to note that `ed` indexes lines starting from `1` instead of `0`.

The `file` may also be preceded by `/re` instead of the line number in order to set the current line as the first line which matches a given regular expression, `re`. `?re` sets the current line to the final line which matches the given regular expression.

To summarize, most `ed` commands operate on `line` addresses. These can look like:

* A specific line number: `5`

* A range of lines: `1,5`

* The current line: `.`

* The last line: `$`

* Relative lines: `.-1`, `.+2`

* A regex match: `/pattern/` (forward), `?pattern?` (backwards)

### Basic Commands
| Command | Meaning                         |
| ---     | ---                             |
|`a`      | Append text after current line  |
|`i`      | Insert text before current line |
|`d`      | Delete current line             |
|`p`      | Print current line              |
|`w`      | Write the buffer to a file      |
|`q`      | Quit the editor                 |
### Interacting with a file
Let's try to make some changes again to our `planets.csv` file. To begin, simply type `ed` followed by the file path:
```bash
ed ./local-universe/milky-way/planets.csv
```
**Output:**
```bash
288
```
In this output, `ed` is telling us that it has read 288 characters into the editor buffer. Now, we can print out all of the lines of the file by running:
```
,p
```
Here, `,` is the **line range address**, and is equivalent to typing `1,$`, meaning "from the first line to the last line". The `p` then is the **command**: print the specified lines.
**Output:**
```ed
Planet, Radius (km), Distance (AU), Mass (T),
Mercury, 2.44E3, 0.39, 3.29E20,
Venus, 6.05E3, 0.72, 4.87E21,
Earth, 6.37E3, 1, 5.97E21,
Mars, 3.39E3, 1.52, 6.42E20,
Jupiter, 7.15E4, 5.2, 1.90E24,
Saturn, 6.03E4, 9.54, 5.69E23,
Uranus, 2.56E4, 19.2, 8.68E22,
Neptune, 2.48E4, 30.1, 1.02E23
```
Now let's say we want to edit the file to change some of the Roman planet names to be their Greek counterparts and then print our changes. We can do this using similar commands to `sed`:
```ed
2s/Mercury/Hermes/
3s/Venus/Aphrodite/
5s/Mars/Ares/
6s/Jupiter/Zeus/
,p
```
**Output:**
```ed
Planet, Radius (km), Distance (AU), Mass (T),
Hermes, 2.44E3, 0.39, 3.29E20,
Aphrodite, 6.05E3, 0.72, 4.87E21,
Earth, 6.37E3, 1, 5.97E21,
Ares, 3.39E3, 1.52, 6.42E20,
Zeus, 7.15E4, 5.2, 1.90E24,
Saturn, 6.03E4, 9.54, 5.69E23,
Uranus, 2.56E4, 19.2, 8.68E22,
Neptune, 2.48E4, 30.1, 1.02E23
```
Now let's say we want to make an addition to the file - let's add the dwarf planets Ceres and Pluto:
```ed
5a
Ceres, 469.7, 2.77, 9.3839E17
.
Pluto, 1.19E3, 49.3, 1.3E19,
```
Let's also be sure to add a `,` to the end of Neptune's line:
```ed
10s/$/,/
```
Now we can check our work again by running `,p`:
```ed
Planet, Radius (km), Distance (AU), Mass (T),
Hermes, 2.44E3, 0.39, 3.29E20,
Aphrodite, 6.05E3, 0.72, 4.87E21,
Earth, 6.37E3, 1, 5.97E21,
Ares, 3.39E3, 1.52, 6.42E20,
Ceres, 469.7, 2.77, 9.38E17,
Jupiter, 7.15E4, 5.2, 1.90E24,
Saturn, 6.03E4, 9.54, 5.69E23,
Uranus, 2.56E4, 19.2, 8.68E22,
Neptune, 2.48E4, 30.1, 1.02E23,
Pluto, 1.19E3, 49.3, 1.3E19,
```
Now we can save our work and exit `ed` by writing the changes to our file and quiting:
```ed
w
q
```
## `ed` vs. `sed`
While `sed` is often the default choice for stream-based editing, there are several reasons you might choose to use `ed` over `sed`, especially in scripting, controlled environments, or low-resource systems.

### Full File Context
`sed` processes input line-by-line and can't refer back to previous lines or look ahead to future ones. In contrast, `ed` loads the entire file into a buffer and lets you operate on arbitrary lines or ranges. This makes `ed` more useful for edits which depend on **file structure** or **relationships between lines**.
### Precise, Scriptable, Line-Oriented Editing
When you know the exact lines you want to manipulate, such as in system-generated files, templates, or structured outputs, `ed` scripts can be extremely short and direct.
### Minimal Dependencies
`ed` is tiny and often present on rescue systems, embedded Linux distros, or initramfs environments. If you're in a minimal shell or bootstrapping a system without `awk`, `sed`, or `vim`, `ed` may be the only editor available.

---

Now that we have a basic understanding of using `sed` and `ed`, let's learn one of the most important tools for effectively utilizing them.[Click here to continue on to the next section](08_shell_scripts.md) where we will learn how to create and execute shell scripts.