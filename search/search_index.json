{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#project-layout","title":"Project layout","text":"<p>Created by Adrian Fisher</p> <pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md                     # The documentation homepage.\n    01_summary_and_setup.md      # Introduction\n    02_navigation.md             # Tips for navigating file system\n    03_command_history.md        # Tips for utilizing command history\n    04_file_operations.md        # Tips for organizing files\n    05_creating_example_files.md # Creating files for examples\n    06_searching_for_files.md    # Tips on how to search for files\n    07_searching_inside_files.md # Tips on searching for content inside files\n    08_editing_files.md          # Explaining ways to edit the content inside files\n    09_shell_scripts.md          # Learning how to script with the shell\n    10_script_example.md         # Putting it all together\n    examples/\n        constellations.csv \n        galaxies.csv\n        planets.csv\n</code></pre>"},{"location":"01_summary_and_setup/","title":"Summary","text":"<p>The Unix shell is more than just a way to launch programs: it's a powerful environment for automating tasks, managing files, and interacting with your system efficiently. Whether you're using <code>bash</code>, <code>zsh</code>, or another variant, Unix shells have the versatility to become a highly personalized and productive workspace when you understand how to use it effectively. </p> <p>In this short series of lessons, we'll cover practical tips and time-saving techniques for working in the shell, such as shortcuts for navigating directories, accessing your command history, interacting with files and directories, editing files directly, interpreting the UI colors, and creating and running personalized shell scripts. </p>"},{"location":"01_summary_and_setup/#install-software","title":"Install Software","text":"<p>If you do not already have it installed, click this link for instructions on how to download and install the Bash shell for Windows, MacOS, or Linux. </p> <p>Click here to continue to the next section where we will go over tips for navigating directories with the Unix shell.</p>"},{"location":"02_navigation/","title":"Navigation","text":"<p>Before you can manage files and run scripts, it's necessary to understand and be comfortable with navigating your file directory from inside the shell. This section will cover tips and common patterns for navigation that will save you time and help prevent mistakes.</p>"},{"location":"02_navigation/#basic-commands","title":"Basic Commands","text":""},{"location":"02_navigation/#pwd","title":"<code>pwd</code>","text":"<p>This command stands for 'Print Working Directory'. This command gives a print out of the path to reach the directory you're currently working from. For instance, if you're opening Linux, <code>pwd</code> might return a path like: <code>/home/userName</code></p>"},{"location":"02_navigation/#ls","title":"<code>ls</code>","text":"<p>List. This command shows the contents of the current directory. </p>"},{"location":"02_navigation/#cd-directory","title":"<code>cd &lt;directory&gt;</code>","text":"<p>Change Directory. This command allows you to move into a different folder.</p> <p>NOTE: You can also use <code>ls &lt;directory&gt;</code> or <code>ls &lt;path&gt;</code> to show the contents of a folder other than the one you're currently in. </p>"},{"location":"02_navigation/#useful-shortcuts","title":"Useful Shortcuts","text":"<ul> <li> <p><code>~</code> represents your home directory path, so <code>cd ~</code> will change your directory to the top of your folder tree and <code>ls ~</code> will show you same folder's contents.</p> </li> <li> <p><code>cd -</code> will return you to the previous directory you were in.</p> </li> <li> <p><code>.</code> refers to the current directory.</p> </li> <li> <p><code>..</code> refers to the parent directory, so <code>cd ..</code> will move you into the parent directory and <code>ls ..</code> will show the contents of the parent directory.</p> </li> </ul>"},{"location":"02_navigation/#-help","title":"<code>--help</code>","text":"<p>Most commands will provide you with a quick guide if you type the command + <code>--help</code>.</p>"},{"location":"02_navigation/#tab-completion","title":"Tab Completion","text":"<p>You can start typing a directory or file name and press <code>Tab</code> to auto-complete. If multiple matches exist, pressing <code>Tab</code> twice will show you the options. This also works inside of different directories, meaning you can use <code>Tab</code> for each directory to shorten how much is needed to type to navigate deeper into a path. For instance:</p> <pre><code>cd Doc&lt;tab&gt;/Git&lt;tab&gt;/\n</code></pre> <p>would move you into the <code>Documents/Github</code> folder (assuming you don't have other objects that start with the same three letters in the same folder). </p> <p>NOTE: Tab completion works slightly differently in different shells. <code>Powershell</code> and <code>Fish</code> are not case sensitive, while <code>Bash</code> and <code>Tcsh</code> are.</p>"},{"location":"02_navigation/#stacking-options","title":"Stacking options","text":"<p>Most commands have a list of options that can be used to modify its results in specific ways. In most cases, it is possible to stack options so that they are all included in the execution of the command. </p> <p>As an example, there are several options that can be added after <code>ls</code> to modify its behavior. <code>-a</code> will show all files, while <code>-A</code> will show almost all files, ignoring files and folders that begin with <code>.</code> and <code>..</code>. <code>-l</code> will use a long listing format, <code>-h</code> will use a human readable format, <code>-r</code> will reverse the result order, and <code>-t</code> will sort by modified time. Stacking these options together allows for more complex list result searches such as:</p> <pre><code>ls -lh # Long listing format with human-readable file sizes\nls -ltr # Long listing format, sort by modified time, oldest first\nls -Alh # Show almost all files, long listing format, human readable\n</code></pre> <p>It is also allowed to list the commands one after the other, such as <code>ls -l -t -r</code>.</p>"},{"location":"02_navigation/#using-tree","title":"Using <code>tree</code>","text":"<p>The <code>tree</code> command visually maps directory structures, making it especially helpful when you need to understand the organization of nested directories. It prints out a representation of your directories where the indentation level indicates subfolders. </p> <p>By default, <code>tree</code> is not installed. For RHEL, CentOS, and Fedora Linux, it can be installed with the commands:</p> <pre><code>sudo yum install tree\n</code></pre> <p>or</p> <pre><code>sudo dnf install tree\n</code></pre> <p>For Debian, Mint, and Ubuntu Linux:</p> <pre><code>sudo apt-get install tree\n</code></pre> <p>And for Apple OS X, it can be installed with:</p> <pre><code>brew install tree\n</code></pre> <p>Just entering <code>tree</code> by itself will output your entire file structure starting from your current directory. Depending on the number of subfolders, this might result in a cluttered mess unless you apply certain options. </p> <p>The basic command format for <code>tree</code> follows:</p> <pre><code>tree [options]\n</code></pre> <p>Some of the more common options for <code>tree</code> include:</p>"},{"location":"02_navigation/#-a-all","title":"<code>-a</code>/<code>--all</code>","text":"<p>These options include hidden files and directories in the results.</p>"},{"location":"02_navigation/#-d-dirs-only","title":"<code>-d</code>/<code>--dirs-only</code>","text":"<p>List directories only.</p>"},{"location":"02_navigation/#-f-full-path","title":"<code>-f</code>/<code>--full-path</code>","text":"<p>Prints the full path prefix for each file.</p>"},{"location":"02_navigation/#-p-prune","title":"<code>-p</code>/<code>--prune</code>","text":"<p>Omits specified directory from the tree.</p>"},{"location":"02_navigation/#-filelimit","title":"<code>--filelimit #</code>","text":"<p>Prevents <code>tree</code> from descending into directories which contain more than <code>#</code> entries.</p>"},{"location":"02_navigation/#-s","title":"<code>-s</code>","text":"<p>Prints the size of each file along with the name.</p>"},{"location":"02_navigation/#-l","title":"<code>-L #</code>","text":"<p>Sets a maximum depth, #, of the directory tree to display.</p> <p>As before, these options can be stacked together for more precise results. For instance, if you only wanted to visualize directories up to 3 folders deep while also wanting to see the path for each file, you could run:</p> <pre><code>tree -dpL 3\n</code></pre> <p>Now that you're familiar with moving around and inspecting the filesystem, let's look at how you can save time using command history and quick recall tools. Click here to continue on to the next section.</p>"},{"location":"03_command_history/","title":"Command History and Quick Recall Tools","text":"<p>Typing the same long commands over and over can get tedious and error prone. Fortunately, Unix shells keep a command history that lets you easily recall, repeat, and modify previous commands. This section covers essential shortcuts and tools to speed up your workflow.</p>"},{"location":"03_command_history/#basic-history-navigation","title":"Basic History Navigation","text":"<ul> <li> <p>Press the up arrow to scroll through previous commands.</p> </li> <li> <p>Press the down arrow to move forward again.</p> </li> </ul> <p>You can also view a full numbered history of your previous commands with:</p> <pre><code>history\n</code></pre>"},{"location":"03_command_history/#reverse-search","title":"Reverse search","text":"<p>Unix supports a reverse search, allowing you to find previous commands by typing in a segment of them. From the shell, press <code>CTRL+R</code> to begin a reverse search. You can then start typing a previous command and the shell will search backward through your history, autocompleting your search on the command line.</p> <ul> <li> <p>Keep pressing <code>CTRL+R</code> to cycle through more matches.</p> </li> <li> <p>Press <code>CTRL+S</code> to search forward</p> </li> <li> <p>Press <code>Enter</code> to run the found command.</p> </li> <li> <p>Press <code>Esc</code> or <code>CTRL+G</code> to cancel the search.</p> </li> </ul>"},{"location":"03_command_history/#using-fish","title":"Using <code>Fish</code>","text":"<p>The Fish shell offers even more intuitive and powerful history navigation tools than supported by a base Unix installation. You can download Fish by following this link to the official site, or in the shell you can run the command:</p> <pre><code>sudo apt install fish\n</code></pre> <p>Once installed, you only need to enter <code>fish</code> on the command line to get started. </p> <p>The Fish shell allows you to begin typing any part of a previous command, and it will automatically suggest matching commands from your history. You can then press the up arrow or down arrow to search through your matching command history. Then, press the right arrow to accept the suggestion, and Enter to run the command.</p> <p>Fish also includes advanced history commands:</p> <ul> <li> <p><code>history search &lt;pattern&gt;</code> shows matching commands. For instance, <code>history search cd</code> would show you each command you've used to change directories in your saved history.</p> </li> <li> <p><code>history delete --prefix &lt;pattern&gt;</code> deletes entries from your history that start with a given prefix.</p> </li> </ul> <p>NOTE:  Note: Fish keeps a separate history per session and per working directory, making it especially useful for project-based work.</p> <p>Fish also helpfully uses syntax highlighting as you type. By default, Fish will color invalid commands red as you write them, and underline valid file paths.</p>"},{"location":"03_command_history/#view-and-edit-commands-before-running","title":"View and Edit Commands Before Running","text":"<p>You can use <code>fc</code> (fix command) to open your previous command in your default editor, such as <code>nano</code>, <code>vim</code>, or <code>emacs</code>. This can be useful for making edits to long or complex commands before re-running them.</p> <p>Now that you can navigate and reuse your command history efficiently, we'll move on to file operations: copying, moving, renaming, and deleting files using the shell. Click here to continue on to the next section.</p>"},{"location":"04_file_operations/","title":"Working with Files","text":"<p>File operations are fundamental to using the Unix shell effectively. Whether you're managing project files, organizing backups, or scripting automation tasks, mastering a few essential commands can greatly streamline your workflow.</p>"},{"location":"04_file_operations/#creating-files-with-touch","title":"Creating files with <code>touch</code>","text":"<p>The <code>touch</code> command follows the basic format of:</p> <pre><code>touch [OPTION] FILE\n</code></pre> <p>The command updates the access and modification times of the selected file to the current time. It can also be used to create a new file if the <code>FILE</code> argument does not exist.</p> <p>While there aren't options to influence the creation of a new file with <code>touch</code> (aside from not creating one using <code>-c</code> or <code>--no-create</code>), there are options to modify the access and modification times of an existing file. Some of the more common options for <code>touch</code> include:</p>"},{"location":"04_file_operations/#-a","title":"<code>-a</code>","text":"<p>Change only the access time.</p>"},{"location":"04_file_operations/#-d-string-datestring","title":"<code>-d [STRING]</code>/<code>--date=STRING</code>","text":"<p>Parse <code>STRING</code> and use it instead of the current time. </p> <p><code>STRING</code> must be in the format <code>[[CC]YY]MMDD</code>. If <code>YY</code> is specified but <code>CC</code> (century) is not, a value for <code>YY</code> between 69 and 99 results in a <code>CC</code> value of 19. Otherwise, <code>CC</code> defaults to a value of 20. So, if you wanted to change the last modified date of a file to be January 1st, 2018, you would use the command:</p> <pre><code>touch -d 20180101 example.txt\n</code></pre>"},{"location":"04_file_operations/#-h-no-dereference","title":"<code>-h</code>/<code>--no-dereference</code>","text":"<p>This command affects symbolic links (symlinks) instead of referenced files.</p>"},{"location":"04_file_operations/#-m","title":"<code>-m</code>","text":"<p>Changes the modification time to the current time.</p>"},{"location":"04_file_operations/#-t-stamp","title":"<code>-t [STAMP]</code>","text":"<p>Parse a <code>STAMP</code> of the format <code>[[CC]YY]MMDDhhmm[.SS]</code> to be the new modification time.</p> <p>The same rules as in <code>-d</code> apply for the <code>[[CC]YY]MMDD</code> part of the argument. The <code>hh</code> argument uses a 24 hour clock (from 00 to 23). For example, if you wished to change the last modified date of a file to January 1st, 2018, at 5:28:30pm, you could use the command:</p> <pre><code>touch -d 201801011728.30 example.txt\n</code></pre> <p>After making a text file, it is common to edit the file using a text editor. For more information on the basics of text editors, you can follow this link to a short series of lessons on three of the most popular text editors, <code>nano</code>, <code>Vim</code>, and <code>Emacs</code>.</p>"},{"location":"04_file_operations/#making-folders-with-mkdir","title":"Making folders with <code>mkdir</code>","text":"<p>The <code>mkdir</code> command will create a new folder if one does not already exist. It follows the basic format of:</p> <pre><code>mkdir [OPTION] DIRECTORY\n</code></pre> <p>Some of the most common options used with <code>mkdir</code> include:</p>"},{"location":"04_file_operations/#-p-parents","title":"<code>-p</code>/<code>--parents</code>","text":"<p>Creates parent directories if necessary. For instance, running the following command without first creating <code>testdir</code> or <code>subdir</code> will create all three directories:</p> <pre><code>mkdir -p testdir/subdir/exampledir\n</code></pre>"},{"location":"04_file_operations/#-v","title":"<code>-v</code>","text":"<p>Print a message for each created directory. This can be useful for automated scripts to show everything that gets created, potentially helping to find errors in directory creation.</p>"},{"location":"04_file_operations/#copying-files-with-cp","title":"Copying files with <code>cp</code>","text":"<p><code>cp</code> copies files or directories. The basic usage looks like:</p> <pre><code>cp [OPTION] SOURCE DEST\n</code></pre> <p>Where <code>SOURCE</code> and <code>DEST</code> would be the old and new filenames. For instance, if you're just copying a file to the same directory and changing its name, that would look like:</p> <pre><code>cp oldfile.txt backup.txt\n</code></pre> <p>You can also copy the original file into a new folder by setting <code>DEST</code> as a directory, such as in:</p> <pre><code>mkdir testdir\ncp oldfile.txt testdir/\n</code></pre> <p>It is also possible to change the name of the copy in the same way:</p> <pre><code>cp oldfile.txt tesdir/backup.txt\n</code></pre> <p>Both <code>SOURCE</code> and <code>DEST</code> can be set as full paths for more precision if needed.</p> <p>Some of the most common options used with <code>cp</code> include:</p>"},{"location":"04_file_operations/#-f-force","title":"<code>-f</code>/<code>--force</code>","text":"<p>If an existing destination file cannot be opened, remove it and try again.</p>"},{"location":"04_file_operations/#-n-no-clobber","title":"<code>-n</code>/<code>--no-clobber</code>","text":"<p>Prevents you from overwriting an existing file.</p>"},{"location":"04_file_operations/#-i-interactive","title":"<code>-i</code>/<code>--interactive</code>","text":"<p>Prompts you for confirmation before overwriting an existing file.</p> <p>NOTE:  Note that <code>-n</code> and <code>-i</code> will override each other. Only the second one will be used.</p>"},{"location":"04_file_operations/#-r-r-recursive","title":"<code>-R</code>/<code>-r</code>/<code>--recursive</code>","text":"<p>Option required to copy a directory. </p>"},{"location":"04_file_operations/#-s-symbolic-link","title":"<code>-s</code>/<code>--symbolic-link</code>","text":"<p>Makes a symbolic link instead of copying the file. A symbolic link is similar to a shortcut, differing from copying in that changes to the original will effect the symbolic link version of the file as well, while copying creates an independant version of the file.</p>"},{"location":"04_file_operations/#move-or-rename-files-with-mv","title":"Move or rename files with <code>mv</code>","text":"<p><code>mv</code> moves files if the target is a directory or renames them if the target includes a new name. This command differs from copying in that only one version of the file or directory is preserved. However the command is otherwise very similar, following the basic usage of:</p> <pre><code>mv [OPTION] SOURCE DEST\n</code></pre> <p>For instance, if you want to move a file to a new directory, you can use:</p> <pre><code>mv oldfile.txt testdir/\n</code></pre> <p>If you wish to rename it in the process:</p> <pre><code>mv oldfile.txt testdir/newname.txt\n</code></pre> <p>If you only wish to rename the file while keeping it in the same directory:</p> <pre><code>mv oldfile.txt newname.txt\n</code></pre> <p><code>mv</code> shares many of its commands with <code>cp</code>, including:</p> <ul> <li> <p><code>-f</code>, <code>--force</code></p> </li> <li> <p><code>-i</code>, <code>--interactive</code>, and</p> </li> <li> <p><code>-n</code>, <code>--no-clobber</code></p> </li> </ul> <p>However, <code>-R</code>, <code>-r</code>, <code>--recursive</code>, <code>-s</code>, and <code>--symbolic-link</code> are not available for the <code>mv</code> command. </p>"},{"location":"04_file_operations/#delete-files-with-rm","title":"Delete files with <code>rm</code>","text":"<p><code>rm</code> deletes/unlinks files or folders, so use this option with caution. Its basic usage follows the format of:</p> <pre><code>rm [OPTION] FILE\n</code></pre> <p>Like with <code>cp</code> and <code>mv</code>, the <code>FILE</code> argument can be a path to a specific file outside of the directory that your shell is inside of.</p> <p>Some of the more common options for <code>rm</code> include:</p>"},{"location":"04_file_operations/#-f-force_1","title":"<code>-f</code>/<code>--force</code>","text":"<p>Ignores nonexistent files and arguments.</p>"},{"location":"04_file_operations/#-i","title":"<code>-i</code>","text":"<p>Prompts the user for confirmation before every removal.</p>"},{"location":"04_file_operations/#-i_1","title":"<code>-I</code>","text":"<p>Prompts the user for confirmation if more than three files would be deleted, or when removing recursively. This is useful for automated scripts.</p>"},{"location":"04_file_operations/#-r-r-recursive_1","title":"<code>-r</code>/<code>-R</code>/<code>--recursive</code>","text":"<p>Remove directories and their contents.</p>"},{"location":"04_file_operations/#-d-dir","title":"<code>-d</code>/<code>--dir</code>","text":"<p>Removes empty directories.</p>"},{"location":"04_file_operations/#destroy-files-with-shred","title":"Destroy files with <code>shred</code>","text":"<p><code>shred</code> is similar to <code>rm</code> in that it makes files unusable, but <code>shred</code> repeatedly overwrites the content, making it unrecoverable. Think of <code>rm</code> as like throwing a file in the garbage, while <code>shred</code> is more like dumping ink over it. It is still possible to recover files that have been removed with <code>rm</code> if you know what you're doing, but it is incredibly difficult to recover files that you <code>shred</code>, even using expensive hardware. Its basic usage follows the format of:</p> <pre><code>shred [OPTION] FILE\n</code></pre> <p>When you <code>shred</code> a file, there will still be a file with the given name and extension, but its contents will be unrecognizable. To demonstrate, try making an example file with a text editor:</p> <pre><code>nano example.txt\n</code></pre> <p>Then, write something to the file, save and quit (<code>CTRL+X</code> \\(\\to\\) <code>Y</code> \\(\\to\\) <code>Enter</code>), and <code>shred</code> the file.</p> <pre><code>shred example.txt\n</code></pre> <p>You can then re-run the command <code>nano example.txt</code> to open the file in your shell to see that your message has been transformed into a jumble of meaningless characters.</p> <p>Some of the more common options for <code>shred</code> include:</p>"},{"location":"04_file_operations/#-f-force_2","title":"<code>-f</code>/<code>--force</code>","text":"<p>Changes permissions to allow writing to the file if it would otherwise not be possible to <code>shred</code> the file.</p>"},{"location":"04_file_operations/#-n-n-iterationsn","title":"<code>-n N</code>/<code>--iterations=N</code>","text":"<p>By default, <code>shred</code> will overwrite the file 3 times. This option allows you to specify how many times, <code>N</code>, to overwrite the file, making it potentially easier or more difficult to recover the data.</p> <pre><code>shred -n 10\n</code></pre>"},{"location":"04_file_operations/#-s-n-sizen","title":"<code>-s N</code>/<code>--size=N</code>","text":"<p>Allows you to specify a number, <code>N</code>, of bytes to overwrite.</p> <pre><code>shred -s 8\n</code></pre> <p>This command will only overwrite the first 8 bytes of a file.</p>"},{"location":"04_file_operations/#-u","title":"<code>-u</code>","text":"<p>Remove file after overwriting it.</p>"},{"location":"04_file_operations/#-z-or-zero","title":"<code>-z</code> or <code>--zero</code>","text":"<p>Add a final overwrite filled with zeros to hide the shredding.</p> <p>Now that you have a handle on creating, destroying, moving, and entering files or directories, click here to continue to the next section where we can start creating some example files to practice searching with.</p>"},{"location":"05_creating_example_files/","title":"Creating Example Files","text":"<p>Now that we've gotten some of the more vital commands down, let's use this as an opportunity to start creating some files that we can test our command knowledge on. This will also help us in future sections to test new commands on. </p> <p>This section will show the creation of three example files, but you can also simply download the three created files with the following links and move them to a directory of your choice:</p> <ul> <li> <p>planets.csv</p> </li> <li> <p>constellations.csv</p> </li> <li> <p>galaxies.csv</p> </li> </ul> <p>If you're creating your files, navigate to a folder that you'd be willing to use for this lesson by using the <code>cd</code> command. From there, create a new folder which can be used to house your example files:</p> <pre><code>mkdir Unix-Tips\n</code></pre> <p>Then, enter this directory using:</p> <pre><code>cd Unix-Tips\n</code></pre> <p>Now let's create and edit some files using the <code>touch</code> command and a text editor of your choice. We'll want to create some files that have several lines with distinct words or phrases for the later sections which will focus on editing and searching. For this example, we'll be creating a couple of files with astronomical data:</p> <pre><code>touch planets.csv\ntouch constellations.csv\ntouch galaxies.csv\n</code></pre> <p>Let's start by creating our <code>planets.csv</code> file. We'll create one line for each planet and include its radius, distance from the sun, and mass. Start by entering:</p> <pre><code>nano planets.csv\n</code></pre> <p>Then, inside the file, we can add our information:</p> <pre><code>Planet, Radius (m), Distance (AU), Mass (Kg),\nMercury, 2.44E6, 0.39, 3.29E23,\nVenus, 6.05E6, 0.72, 4.87E24,\nEarth, 6.37E6, 1, 5.97E24,\nMars, 3.39E6, 1.52, 6.42E23,\nJupiter, 7.15E7, 5.2, 1.90E27,\nSaturn, 6.03E7, 9.54, 5.69E26,\nUranus, 2.56E7, 19.2, 8.68E25,\nNeptune, 2.48E7, 30.1, 1.02E26\n</code></pre> <p>Then save and exit the file before creating data for the second two files. Next will be:</p> <pre><code>nano constellations.csv\n</code></pre> <p>With data from the Zodiac constellations:</p> <pre><code>Constellation, Brightest Star,\nAries, Hamal,\nTaurus, Aldebaran,\nGemini, Pollux,\nCancer, Al Tarf,\nLeo, Regulus,\nVirgo, Spica,\nLibra, Zubeneschamali,\nScorpius, Antares,\nOphiuchus, Rasalhague,\nSagittarius, Kaus Australis,\nCapricornus, Deneb Algedi,\nAquarius, Sadalsuud,\nPisces, Alpherg,\n</code></pre> <p>And finally, let's fill galaxies.csv with a small selection of galaxies in our local group:</p> <pre><code>nano galaxies.csv\n</code></pre> <pre><code>Galaxy, Constellation, Type,\nAndromeda, Andromeda, Spiral,\nMilky Way (Center), Sagittarius, Spiral,\nTriangulum, Triangulum, Spiral,\nPisces Dwarf, Pisces, Irregular,\nLeo A, Leo, Irregular,\n</code></pre> <p>Now, let's create some sub-directories inside <code>Unix-Tips</code>:</p> <pre><code>mkdir local-universe\nmkdir local-universe/milky-way\n</code></pre> <p>It's now only a couple commands to move our files into their respective directories:</p> <pre><code>mv planets.csv local-universe/milky-way\nmv constellations.csv local-universe/milky-way\nmv galaxies.csv local-universe/\n</code></pre> <p>You should now have a file tree similar to:</p> <pre><code>Unix-Tips\n    \u2514\u2500\u2500 local-universe\n        \u251c\u2500\u2500 galaxies.csv\n        \u2514\u2500\u2500 milky-way\n            \u251c\u2500\u2500 constellations.csv\n            \u2514\u2500\u2500 planets.csv\n</code></pre> <p>Now that we have some examples, click here to continue to the next section where we can learn some powerful tools that can be used to search for files.</p>"},{"location":"06_searching_for_files/","title":"Using <code>find</code> to Search Filenames","text":"<p>The <code>find</code> command recursively searches for files by name, type, size, or modification time. By default, the command prints the names of the files for which your entire expression is <code>true</code>.</p> <p><code>find</code> searches your directory tree rooted from a given starting point, evaluating the given expression from left to right until the outcome is determined as <code>True</code> or <code>False</code>, at which point <code>find</code> moves on to the next file. Without a specified search root, the current directory, <code>.</code>, is assumed. Also, if a starting point argument would normally begin with <code>-</code>, <code>find</code> would try to treat it instead as an expression. For this reason, it is generally safer to prefix any wildcard or dubius path names with <code>./</code>, or to use absolute paths such as <code>/home/user/Unix-Tips</code>.</p> <p>The <code>find</code> command follows the format:</p> <pre><code>find [PATH] [EXPRESSION]\n</code></pre> <p>The <code>expressions</code> used to select files are comprised of one or more of four primaries: <code>options</code>, <code>tests</code>, <code>actions</code>, and <code>operators</code>. </p> <p>If you're not already, let's move into the <code>Unix-Tips</code> directory to practice some of these expressions.</p> <pre><code>cd Unix-Tips\n</code></pre>"},{"location":"06_searching_for_files/#1-options","title":"1. <code>options</code>","text":"<p>These affect the overall operation. Where to search instead of what to search. Let's look at some of the most common <code>options</code>:</p>"},{"location":"06_searching_for_files/#-maxdepth-n","title":"<code>-maxdepth [N]</code>","text":"<p>Limits how many subdirectories deep your expression will search starting from the search root.</p> <pre><code>find . -maxdepth 2 -name \"*.csv\"\n</code></pre> <p>Output</p> <pre><code>./local-universe/galaxies.csv\n</code></pre>"},{"location":"06_searching_for_files/#-mindepth-n","title":"<code>-mindepth [N]</code>","text":"<p>Skips a number of directory levels before applying tests.</p> <pre><code>find . -mindepth 3 -name \"*.csv\"\n</code></pre> <p>Output:</p> <pre><code>./local-universe/milky-way/constellations.csv\n./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#-depth","title":"<code>-depth</code>","text":"<p>Processes directory contents starting from the current directory without leaving behind empty directories or causing accidental deletion issues.</p>"},{"location":"06_searching_for_files/#-xdev-mount","title":"<code>-xdev</code>/<code>-mount</code>","text":"<p>Prevents find from descending into directories that are on different filesystems than the starting point. This is especially useful when you're searching from a top-level directory like <code>/</code>, and you want to avoid scanning mounted drives, network shares, or other partitions (e.g., <code>/proc</code>, <code>/mnt</code>, <code>/media</code>, etc.).</p>"},{"location":"06_searching_for_files/#2-tests","title":"2. <code>tests</code>","text":"<p>These return a true or false value depending on the file's attributes. Here are some examples for the most common <code>find</code> <code>tests</code>:</p>"},{"location":"06_searching_for_files/#-name-pattern-iname-pattern","title":"<code>-name PATTERN</code>/<code>-iname PATTERN</code>","text":"<p>Matches files by name. <code>-iname</code> is case-insensitive. Wildcards like <code>*</code> and <code>?</code> are supported.</p> <pre><code>find . -name \"pl*\"\n</code></pre> <p>Output:</p> <pre><code>./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#-type","title":"<code>-type</code>","text":"<p>Matches by file type:</p> <ul> <li> <p><code>f</code>: Regular file</p> </li> <li> <p><code>d</code>: Directory</p> </li> <li> <p><code>l</code>: Symbolic link</p> </li> </ul> <pre><code>find . -type d\n</code></pre> <p>Output:</p> <pre><code>.\n./local-universe\n./local-universe/milky-way\n</code></pre>"},{"location":"06_searching_for_files/#-mtime-n-mmin-n","title":"<code>-mtime N</code>/<code>-mmin N</code>","text":"<p>Matches files and folders by modification time. <code>-mtime</code> uses days, <code>-mmin</code> uses minutes. Let's say I've recently edited <code>galaxies.csv</code>, but none of the other files:</p> <pre><code>find . -mtime -1 # Find objects modified in the last day\n</code></pre> <p>Output:</p> <pre><code>.\n./local-universe/galaxies.csv\n</code></pre> <pre><code>find . -mmin +60 # Find objects modified more than an hour ago\n</code></pre> <p>Output:</p> <pre><code>.\n./local-universe\n./local-universe/milky-way\n./local-universe/milky-way/constellations.csv\n./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#-size-nbckmg","title":"<code>-size N[b|c|k|M|G]</code>","text":"<p>Matches files by size.</p> <ul> <li> <p><code>b</code>: 512-byte blocks</p> </li> <li> <p><code>c</code>: bytes</p> </li> <li> <p><code>k</code>: Kb</p> </li> <li> <p><code>M</code>: Mb</p> </li> <li> <p><code>G</code>: Gb</p> </li> </ul> <pre><code>find . -size +10M  # Find files larger than 10 Mb\nfind . -size -100k # Find files smaller than 100 Kb\nfind . -size 3b    # Find files that are exactly 3 blocks\n</code></pre>"},{"location":"06_searching_for_files/#-user-name-group-name","title":"<code>-user NAME</code>/<code>-group NAME</code>","text":"<p>Find files owned by a specific user or group.</p> <pre><code>find /home -user admin # Find files owned by user named admin\n</code></pre> <p>NOTE: <code>-nouser</code> and <code>-nogroup</code> can be used to find files with no associated user or group. Those commands are often used for deleted accounts. </p>"},{"location":"06_searching_for_files/#-empty","title":"<code>-empty</code>","text":"<p>Match empty files or directories</p> <pre><code>find . -type f -empty # Find empty files\nfind . -type d -empty # Find empty directories\n</code></pre>"},{"location":"06_searching_for_files/#-path-wholename","title":"<code>-path</code>/<code>-wholename</code>","text":"<p>Match full relative path (from search root)</p> <pre><code>find . -path \"./local-universe/milky-way/*.csv\"\n</code></pre> <p>Output:</p> <pre><code>./local-universe/milky-way/constellations.csv\n./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#-newer-file-anewer-file-cnewer-file","title":"<code>-newer FILE</code>/<code>-anewer FILE</code>/<code>-cnewer FILE</code>","text":"<p>Match files based on their modified/access/change times respectively.</p> <pre><code>find . -newer constellations.csv # Find files modified more recently than constellations.csv\n</code></pre> <p>Output:</p> <pre><code>.\n./local-universe\n./local-universe/galaxies.csv\n./local-universe/milky-way\n</code></pre>"},{"location":"06_searching_for_files/#-readable-writable-executable","title":"<code>-readable</code>/<code>-writable</code>/<code>-executable</code>","text":"<p>Checks the accessibilities for the current user.</p> <pre><code>find . -type f -writable\n</code></pre> <p>Output:</p> <pre><code>./local-universe/galaxies.csv\n./local-universe/milky-way/constellations.csv\n./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#3-actions","title":"3. <code>actions</code>","text":"<p>These have side effects, but otherwise also return a <code>True</code> or <code>False</code> value. Here are some of the most common <code>find</code> <code>actions</code>:</p>"},{"location":"06_searching_for_files/#-print","title":"<code>-print</code>","text":"<p>This is the default action which does not normally need to be specified. <code>-print</code> prints the patch of each file which matches the rest of the expression. It is useful to explicitly call <code>-print</code> when your expression includes actions or tests that don't automatically print their results, especially when chaining multiple conditions such as <code>-exec</code>, <code>-delete</code>, or <code>-ok</code>.</p>"},{"location":"06_searching_for_files/#-fprint-file","title":"<code>-fprint FILE</code>","text":"<p>This prints the result into a given <code>FILE</code> followed by a newline. This will also create the <code>FILE</code> if it does not already exist.</p> <pre><code>find . -name \"*.csv\" -fprint ./csv_list.txt \n</code></pre> <p>This command creates a new file named \"csv_list.txt\" which contains a list of all the .csv files.</p>"},{"location":"06_searching_for_files/#-delete","title":"<code>-delete</code>","text":"<p>Deletes each file which matches the expression: Use with caution. This command is often combined with <code>-type</code> to avoid deleting directories or special files by accident.</p> <pre><code>find ./Unix-Tips -name \"*.txt\" -delete \n</code></pre>"},{"location":"06_searching_for_files/#-exec-command","title":"<code>-exec COMMAND {} \\;</code>","text":"<p>Runs a command for each matching file. The shell substitutes <code>{}</code> with the full path to the file when running. <code>\\;</code> then terminates the command.</p> <p>You can also replace <code>\\;</code> with <code>+</code> to have the command run once with multiple file arguments instead of once per file.</p> <pre><code>find . -name \"*.txt\" -exec gzip {} \\;\n</code></pre> <p>This command will run <code>gzip</code> on all <code>.txt</code> files.</p>"},{"location":"06_searching_for_files/#-prune","title":"<code>-prune</code>","text":"<p>Stops <code>find</code> from descending into matching directories. This action is common for skipping paths.</p> <pre><code>find local-universe -path \"local-universe/milky-way\" -prune -o -name \"*.csv\" \n</code></pre> <p>Output:</p> <pre><code>local-universe/galaxies.csv\nlocal-universe/milky-way\n</code></pre>"},{"location":"06_searching_for_files/#-quit","title":"<code>-quit</code>","text":"<p>Stops after the first match. Useful for fast existence checks.</p> <pre><code>find . -name \"*.csv\" -print -quit\n</code></pre> <p>Output:</p> <pre><code>./local-universe/galaxies.csv\n</code></pre>"},{"location":"06_searching_for_files/#less-common-actions-that-are-still-useful-in-scripts","title":"Less common <code>actions</code> that are still useful in scripts:","text":""},{"location":"06_searching_for_files/#-print0-and-fprint0-file","title":"<code>-print0</code> and <code>-fprint0 FILE</code>","text":"<p>Prints filenames with a null character instead of a newline. This action is ideal for filenames which include spaces.</p>"},{"location":"06_searching_for_files/#-ls","title":"<code>-ls</code>","text":"<p>Prints <code>ls -dils</code> style info for each file.</p>"},{"location":"06_searching_for_files/#-ok-command","title":"<code>-ok COMMAND ;</code>","text":"<p>Like <code>-exec</code>, but prompts for confirmation before running each command.</p>"},{"location":"06_searching_for_files/#-execdir-okdir","title":"<code>-execdir</code>, <code>-okdir</code>","text":"<p>Like <code>-exec</code>, but runs the command in the directory of the matching file instead of where <code>find</code> was run. Useful when the command depends on relative paths.</p>"},{"location":"06_searching_for_files/#4-operators","title":"4. <code>operators</code>:","text":"<p><code>find</code> allows for you to combine multiple tests using logical operators such as AND, OR, and NOT. These combinations can then also be grouped with parentheses. <code>operators</code> can be very powerful for creating more precise search expressions:</p>"},{"location":"06_searching_for_files/#-and-aspace","title":"<code>-and</code>/<code>-a</code>/space","text":"<p>All expressions must be true. This is the defualt behavior of <code>find</code>: listing conditions with spaces will automatically assume <code>-and</code>, but it can be writen explicitely.</p> <pre><code>find . -type f -and -name \"*.csv\"\n</code></pre> <p>This is equivalent to:</p> <pre><code>find . -type f -name \"*.csv\"\n</code></pre>"},{"location":"06_searching_for_files/#-or-o","title":"<code>-or</code>/<code>-o</code>","text":"<p>Matches if either condition is true.</p> <pre><code>find . \\( -name \"galaxies.csv\" -or -name \"planets.csv\" \\)\n</code></pre> <p>Output:</p> <pre><code>./local-universe/galaxies.csv\n./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#-not","title":"<code>-not</code>/<code>!</code>","text":"<p>Inverts a test</p> <pre><code>find . -type f ! -name \"planets.csv\"\n</code></pre> <p>Output:</p> <pre><code>./local-universe/galaxies.csv\n./local-universe/milky-way/constellations.csv\n./csv_list.txt\n</code></pre>"},{"location":"06_searching_for_files/#grouping-using-and","title":"Grouping using <code>(</code> and <code>)</code>","text":"<p>Allows for the grouping of expressions. Must be escaped or quoted in most shells in order to avoid shell interpretation: <code>\\(...\\)</code> such as in the <code>-or</code> example.</p>"},{"location":"06_searching_for_files/#operation-precedence","title":"Operation Precedence","text":"<p><code>find</code> lists the precedence order for operators from highest to lowest as:</p> <ol> <li> <p><code>()</code></p> </li> <li> <p><code>!</code>/<code>-not</code></p> </li> <li> <p>Then <code>-and</code></p> </li> <li> <p>Then <code>-or</code></p> </li> </ol> <p>Now that we have a better handle on searching for specific files, click here to continue on to the next section to learn how to search for specific text inside of your files.</p>"},{"location":"07_searching_inside_files/","title":"Using <code>grep</code> to Search Inside Files","text":"<p>The <code>grep</code> command (a contraction of \"global/regular expression/print\") allows for searching through text files with commands to perform simple or recursive searches, while also allowing for multiple search terms, the ability to count matches, and even allowing users to pipe the output to other commands for further manipulation.</p> <p>The basic syntax of <code>grep</code> follows:</p> <pre><code>grep [OPTIONS] [PATTERNS] [FILES]\n</code></pre> <p><code>grep</code> will then search for the given <code>PATTERN</code> in each of the listed files, and by default will then simply print the related line. The available options for <code>grep</code> are separated into 4 different groups:</p>"},{"location":"07_searching_inside_files/#1-pattern-selection-and-interpretation","title":"1: Pattern Selection and Interpretation","text":"<p>These options define how <code>grep</code> understands and applies your search pattern, allowing you to switch between simple string matching and the more powerful regular expressions, as well as allowing you to control case sensitivity and match boundaries. The most common options you'll use here are:</p>"},{"location":"07_searching_inside_files/#-i-ignore-case","title":"<code>-i</code>/<code>--ignore-case</code>","text":"<p>Ignores case sensitivity.</p> <pre><code>grep -i 'spiral' ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>Andromeda, Andromeda, Spiral,\nMilky Way (Center), Sagittarius, Spiral,\nTriangulum, Triangulum, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-w-word-regexp","title":"<code>-w</code>/<code>--word-regexp</code>","text":"<p>Match with a whole word.</p> <pre><code>grep -w 'Al' ./local-universe/milky-way/constellations.csv\n</code></pre> <p>Output:</p> <pre><code>Cancer, Al Tarf,\n</code></pre> <p>Without the <code>-w</code>, <code>grep</code> would return:</p> <pre><code>Taurus, Aldebaran,\nCancer, Al Tarf,\nCapricornus, Deneb Algedi,\nPisces, Alpherg\n</code></pre>"},{"location":"07_searching_inside_files/#-e-extended-regexp","title":"<code>-E</code>/<code>--extended-regexp</code>","text":"<p>Allows your <code>PATTERN</code> to be interpreted as an extended regular expression. This allows for more complex syntax like <code>+</code>, <code>?</code>, and <code>|</code> without needing backslashes. For instance, to find entries that start with either \"A\" or \"S\", you could use an expression like:</p> <pre><code>grep -E '^(A|S)' ./local-universe/milky-way/constellations.csv\n</code></pre> <p>Output:</p> <pre><code>Aries, Hamal,\nScorpius, Antares,\nSagittarius, Kaus Australis,\nAquarius, Sadalsuud,\n</code></pre>"},{"location":"07_searching_inside_files/#-e-pattern-regexppattern","title":"<code>-e PATTERN</code>/<code>--regexp=PATTERN</code>","text":"<p>Search using multiple patterns.</p> <pre><code>grep -e 'Pisces' -e 'Taurus' ./local-universe/milky-way/constellations.csv\n</code></pre> <p>Output:</p> <pre><code>Taurus, Aldebaran,\nPisces, Alpherg\n</code></pre>"},{"location":"07_searching_inside_files/#-f-file-filefile","title":"<code>-f FILE</code>/<code>--file=FILE</code>","text":"<p>This allows you to use a file to provide the search patterns, loading one pattern per line.</p> <p>Let's say we know a couple of the brightest stars in some constellations, but don't know the names of the constellations themselves. We can create a pattern file:</p> <pre><code>nano pattern.txt\n</code></pre> <p>And then fill it with the stars we know:</p> <pre><code>Hamal\nAldebaran\nAl Tarf\nRasalhague\nDeneb Algedi\nAlpherg\n</code></pre> <p>Now you can use grep to find which lines contain those stars:</p> <pre><code>grep -f ./pattern.txt ./local-universe/milky-way/constellations.csv\n</code></pre> <p>Output:</p> <pre><code>Aries, Hamal,\nTaurus, Aldebaran,\nCancer, Al Tarf,\nOphiuchus, Rasalhague,\nCapricornus, Deneb Algedi,\nPisces, Alpherg\n</code></pre>"},{"location":"07_searching_inside_files/#-f-fixed-strings","title":"<code>-F</code>/<code>--fixed-strings</code>","text":"<p>Treats your pattern as a literal string instead of a regular expression. A literal string is a search pattern that is matched exactly as written without treating any characters as special.</p>"},{"location":"07_searching_inside_files/#-g-basic-regexp","title":"<code>-G</code>/<code>--basic-regexp</code>","text":"<p>Uses basic regular expressions, and is the default mode of <code>grep</code> unless overridden by other options. Special characters require escaping with this option.</p>"},{"location":"07_searching_inside_files/#-no-ignore-case","title":"<code>--no-ignore-case</code>","text":"<p>Explicitly disable case-insensitive matching. This can be useful when searching for lines that might contain the same spelling but with different capitalisation, such as <code>LEO</code> vs <code>Leo</code>.</p>"},{"location":"07_searching_inside_files/#-x-line-regexp","title":"<code>-x</code>/<code>--line-regexp</code>","text":"<p>Matches entire lines exactly.</p>"},{"location":"07_searching_inside_files/#-z-null-data","title":"<code>-z</code>/<code>--null-data</code>","text":"<p>Treat input as null-delimited. This option is useful for special binary or structured formats. Each \"line\" ends in a null byte (<code>\\0</code>) instead of a newline.</p>"},{"location":"07_searching_inside_files/#2-miscellaneous","title":"2: Miscellaneous","text":"<p>These options don't directly affect how <code>grep</code> interprets or searches for patterns but help with controlling its behaviour, output, or interaction with the shell.</p>"},{"location":"07_searching_inside_files/#-s-no-messages","title":"<code>-s</code>/<code>--no-messages</code>","text":"<p>Suppresses error messages about unreadable files.</p>"},{"location":"07_searching_inside_files/#-v-invert-match","title":"<code>-v</code>/<code>--invert-match</code>","text":"<p>Selects lines that do not match the given pattern. Often used to exclude known entries or to filter out unwanted matches. For instance, let's say we want to invert the search from our <code>-f</code> example, <code>pattern.txt</code>.</p> <pre><code>grep -v -f pattern.txt ./local-universe/milky-way/constellations.csv\n</code></pre> <p>Output:</p> <pre><code>Constellation, Brightest Star,\nGemini, Pollux,\nLeo, Regulus,\nVirgo, Spica,\nLibra, Zubeneschamali,\nScorpius, Antares,\nSagittarius, Kaus Australis,\nAquarius, Sadalsuud,\n</code></pre>"},{"location":"07_searching_inside_files/#3-output-control","title":"3: Output Control","text":"<p>These options customize how <code>grep</code> displays its results. They are able to help you manage large outputs, script more effectively, and integrate with tools that expect specific formats.</p>"},{"location":"07_searching_inside_files/#-m-num-max-countnum","title":"<code>-m NUM</code>/<code>--max-count=NUM</code>","text":"<p>Stop reading a file after finding the first <code>NUM</code> matching lines.</p> <pre><code>grep -m 3 'ar' -i ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>Milky Way (Center), Sagittarius, Spiral,\nPisces Dwarf, Pisces, Irregular,\nLeo A, Leo, Irregular\n</code></pre>"},{"location":"07_searching_inside_files/#-b-byte-offset","title":"<code>-b</code>/<code>--byte-offset</code>","text":"<p>Prints the byte offset (position) of each matching line's start within the file.</p> <pre><code>grep -b 'Spiral' ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>29:Andromeda, Andromeda, Spiral,\n59:Milky Way (Center), Sagittarius, Spiral,\n100:Triangulum, Triangulum, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-n-line-number","title":"<code>-n</code>/<code>--line-number</code>","text":"<p>Show the line number for each match. This is especially helpful when working with large files.</p> <pre><code>grep -n 'Spiral' ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>2:Andromeda, Andromeda, Spiral,\n3:Milky Way (Center), Sagittarius, Spiral,\n4:Triangulum, Triangulum, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-line-buffered","title":"<code>--line-buffered</code>","text":"<p>Flushes output after every line instead of buffering. Useful for piping <code>grep</code> into tools that need live output.</p>"},{"location":"07_searching_inside_files/#-h-with-filename","title":"<code>-H</code>/<code>--with-filename</code>","text":"<p>Always show the file name in the output. This is a default option when multiple files are searched.</p> <pre><code>grep -H 'Spiral' ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>./local-universe/galaxies.csv:Andromeda, Andromeda, Spiral,\n./local-universe/galaxies.csv:Milky Way (Center), Sagittarius, Spiral,\n./local-universe/galaxies.csv:Triangulum, Triangulum, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-h-no-filename","title":"<code>-h</code>/<code>--no-filename</code>","text":"<p>Suppress the file name output, such as when searching for multiple files if you only care about the content, not which file the content is from.</p>"},{"location":"07_searching_inside_files/#-o-only-matching","title":"<code>-o</code>/<code>--only-matching</code>","text":"<p>Prints only the part of each line that matches the search pattern.</p> <pre><code>grep -o 'Spiral' ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>Spiral\nSpiral\nSpiral\n</code></pre>"},{"location":"07_searching_inside_files/#-q-quiet-silent","title":"<code>-q</code>/<code>--quiet</code>/<code>--silent</code>","text":"<p>Suppresses all normal outputs. This is useful for testing the presence or absence of a pattern in scripts.</p> <pre><code>grep -q 'Spiral' ./local-universe/galaxies.csv &amp;&amp; echo \"Spiral found.\"\n</code></pre> <p>Output:</p> <pre><code>Spiral found.\n</code></pre>"},{"location":"07_searching_inside_files/#-binary-filestype","title":"<code>--binary-files=TYPE</code>","text":"<p>Choose how to handle binary files.</p> <ul> <li> <p><code>binary</code>: Treat as binary (default).</p> </li> <li> <p><code>text</code>: Treat as if plain text.</p> </li> <li> <p><code>without-match</code>: Silently skip binary files.</p> </li> </ul> <p>NOTE: <code>a</code>/<code>--text</code> are equivalent to <code>--binary-files=text</code></p> <p><code>-I</code> is equivalent to <code>--binary-files=without-match</code></p>"},{"location":"07_searching_inside_files/#-d-action-directoriesaction","title":"<code>-d ACTION</code>/<code>--directories=ACTION</code>","text":"<p>Allows you to choose what to do with directories.</p> <ul> <li> <p><code>read</code>: Read them as files.</p> </li> <li> <p><code>recurse</code>: Search inside of them recursively.</p> </li> <li> <p><code>skip</code>: Ignore them (this is the default unless <code>-r</code> is used).</p> </li> </ul>"},{"location":"07_searching_inside_files/#-d-action-devicesaction","title":"<code>-D ACTION</code>/<code>--devices=ACTION</code>","text":"<p>Similar to <code>-d</code>, but for device files, FIFOs, or sockets.</p>"},{"location":"07_searching_inside_files/#-r-recursive","title":"<code>-r</code>/<code>--recursive</code>","text":"<p>Recursively searches subdirectories (does not follow symlinks).</p> <pre><code>grep -r 'Earth'\n</code></pre> <p>Output:</p> <pre><code>./local-universe/milky-way/planets.csv:Earth, 6.37E6, 1, 5.97E24,\n</code></pre>"},{"location":"07_searching_inside_files/#-r-dereference-recursive","title":"<code>-R</code>/<code>--dereference-recursive</code>","text":"<p>Like <code>-r</code>, but does follow symlinks.</p>"},{"location":"07_searching_inside_files/#-includeglob","title":"<code>--include=GLOB</code>","text":"<p>Restrict search to files matching a glob pattern. For instance, if you only wish to search inside of <code>.txt</code> files, you can run something like:</p> <pre><code>grep -r --include=\"*.txt\" 'Hamal'\n</code></pre> <p>Output:</p> <pre><code>pattern.txt:Hamal\n</code></pre>"},{"location":"07_searching_inside_files/#-excludeglob","title":"<code>--exclude=GLOB</code>","text":"<p>Skips files that match the pattern.</p>"},{"location":"07_searching_inside_files/#-exclude-fromfile","title":"<code>--exclude-from=FILE</code>","text":"<p>Read exclusion patterns (one per line) from a given file. Let's create a new file named <code>exclude-pattern.txt</code> and fill it with some files we want to avoid in a search:</p> <pre><code>nano exclude-pattern.txt\n</code></pre> <p>Which will then contain:</p> <pre><code>galaxies.csv\nplanets.csv\n</code></pre> <p>Then, if we wanted to use a recursive search to find only constellations with \"Leo\" in their names (skipping the Leo A galaxy), we could run:</p> <pre><code>grep -r --exclude-from=exclude-pattern.txt 'Leo'\n</code></pre> <p>Output:</p> <pre><code>local-universe/milky-way/constellations.csv:Leo, Regulus,\n</code></pre>"},{"location":"07_searching_inside_files/#-exclude-dirglob","title":"<code>--exclude-dir=GLOB</code>","text":"<p>Skip directories that match the pattern. To skip the `milky-way/' subdirectory, you could run:</p> <pre><code>grep -r --exclude-dir=\"milky-way\" 'Tri'\n</code></pre> <p>Output:</p> <pre><code>local-universe/galaxies.csv:Triangulum, Triangulum, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-l-files-without-match","title":"<code>-L</code>/<code>--files-without-match</code>","text":"<p>Prints the names of files that contain no matches. To find files that don't contain the word \"Spiral\", you could use:</p> <pre><code>grep -rL 'Spiral'\n</code></pre> <p>Output:</p> <pre><code>exclude-pattern.txt\nlocal-universe/milky-way/constellations.csv\nlocal-universe/milky-way/planets.csv\ncsv_list.txt\npattern.txt\n</code></pre>"},{"location":"07_searching_inside_files/#-l-files-with-matches","title":"<code>-l</code>/<code>--files-with-matches</code>","text":"<p>Prints the names of files with at least one match.</p> <pre><code>grep -rl 'Leo'\n</code></pre> <p>Output:</p> <pre><code>local-universe/galaxies.csv\nlocal-universe/milky-way/constellations.csv\n</code></pre>"},{"location":"07_searching_inside_files/#-c-count","title":"<code>-c</code>/<code>--count</code>","text":"<p>Prints a count of the number of matches per file instead returning the actual matches.</p> <pre><code>grep -rc 'Al'\n</code></pre> <p>Output:</p> <pre><code>exclude-pattern.txt:0\nlocal-universe/galaxies.csv:0\nlocal-universe/milky-way/constellations.csv:4\nlocal-universe/milky-way/planets.csv:0\ncsv_list.txt:0\npattern.txt:4\n</code></pre>"},{"location":"07_searching_inside_files/#-t-initial-tab","title":"<code>-T</code>/<code>--initial-tab</code>","text":"<p>Align fields properly if tab characters are present in the output.</p>"},{"location":"07_searching_inside_files/#-z-null","title":"<code>-Z</code>/<code>--null</code>","text":"<p>Output a null character (<code>\\0</code>) after file names. This can be useful when filenames contain spaces or newlines.</p>"},{"location":"07_searching_inside_files/#4-context-control","title":"4: Context Control","text":"<p>When searching for a pattern in a file, sometimes the goal is to see not just the matching line, but also the surrounding context. <code>grep</code> provides a set of options to include lines before or after matches, which can be especially helpful in logs, source code, or debugging outputs.</p>"},{"location":"07_searching_inside_files/#-b-num-before-contextnum","title":"<code>-B NUM</code>/<code>--before-context=NUM</code>","text":"<p>Show <code>NUM</code> lines before each match.</p> <pre><code>grep -B 1 \"Andromeda\" ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>local-universe/galaxies.csv-Galaxy, Constellation, Type,\nlocal-universe/galaxies.csv:Andromeda, Andromeda, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-a-num-after-contextnum","title":"<code>-A NUM</code>/<code>--after-context=NUM</code>","text":"<p>Show <code>NUM</code> lines after each match.</p> <pre><code>grep -A 1 \"Andromeda\" ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>Andromeda, Andromeda, Spiral,\nMilky Way (Center), Sagittarius, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-c-num-contextnum-num","title":"<code>-C NUM</code>/<code>--context=NUM</code>/<code>-NUM</code>","text":"<p>Show <code>NUM</code> lines before and after each match.</p> <pre><code>grep -C 1 \"Andromeda\" ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>Galaxy, Constellation, Type,\nAndromeda, Andromeda, Spiral,\nMilky Way (Center), Sagittarius, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-group-separatorsep","title":"<code>--group-separator=SEP</code>","text":"<p>Insert <code>SEP</code> between blocks of matches when context is shown. Default is <code>--</code>.</p>"},{"location":"07_searching_inside_files/#-no-group-separator","title":"<code>--no-group-separator</code>","text":"<p>Suppresses the line between context-separated match blocks entirely.</p> <p>These options are useful when post-processing <code>grep</code> output and want consistent formatting or no interruptions between context groups.</p>"},{"location":"07_searching_inside_files/#-colorwhen-colourwhen","title":"<code>--color[=WHEN]</code>/<code>--colour[=WHEN]</code>","text":"<p>Highlight matching text using ANSI escape sequences. <code>WHEN</code> can be:</p> <ul> <li> <p><code>always</code>: Force color, even when not writing to a terminal.</p> </li> <li> <p><code>never</code>: Disable color.</p> </li> <li> <p><code>auto</code>: Color only if output goes to a terminal.</p> </li> </ul> <p>Most modern terminal setups default to <code>--color=auto</code>.</p>"},{"location":"07_searching_inside_files/#-u-binary","title":"<code>-U</code>/<code>--binary</code>","text":"<p>Disable stripping of <code>\\r</code> (carriage return) characters at the end of lines. This is useful when dealing with files from Windows systems (CRLF line endings). This option helps preserve exact formatting in mixed-platform environments.</p> <p>Now that we understand better how to search within files, let's learn how we can edit files from the command shell. Click here to continue on to the next section.</p>"},{"location":"08_editing_files/","title":"Editing Files with <code>sed</code> and <code>ed</code>","text":"<p>While graphical or full-screen editors like <code>nano</code>, <code>vim</code>, and <code>emacs</code> are interactive, Unix also provides stream-based and line-based editors that are ideal for scripting or batch processing. Two of the most powerful tools for this are <code>sed</code> and <code>ed</code>.</p>"},{"location":"08_editing_files/#using-sed","title":"Using <code>sed</code>","text":"<p><code>sed</code> works by reading a file line-by-line and applying transformation rules, often in the form of substitutions, deletions, or insertions. It is especially useful for making changes to large files or automating repetitive edits.</p> <p>The basic syntax of <code>sed</code> follows:</p> <pre><code>sed [OPTIONS] 'COMMANDS' filename\n</code></pre> <p>When replacing/substituting text using <code>sed</code>, the general format of the <code>'COMMAND'</code> should follow:</p> <pre><code>'s/pattern/replacement/[flags]'\n</code></pre> <p>Here, <code>s</code> stands for substitute. This tells <code>sed</code> that the goal is to search and replace. The <code>pattern</code> can then be a word, regex, or a complex pattern. The <code>replacement</code> is then what you are telling <code>sed</code> to replace the <code>pattern</code> with. Finally, <code>[flags]</code> represents the optional modifiers: | Flag       | Meaning                                 | |:---        |  ---                                    | |<code>g</code>         | Global - replace all matches            | |<code>1,2,...</code>   | Replace only the nth match              | |<code>p</code>         | Print only the substituded line         | |<code>I</code>         | Ignore case while searching             | |<code>e</code>         | Substitude and execute the command line |</p> <p>If you don't use one of the <code>flags</code> (i.e 's/pattern/replacement/'), it will only replace the first match. You can also use multiple flags in conjunction with one another. For instance, if you wanted to go line by line and replace every instance of a pattern after the third, while also ignoring case, you could use the flag <code>3Ig</code>. For clarity: this would not go from the third in the file on, but from the third in the line on, resetting the counter with each new line. </p> <p>Let's take a look at how to use some of the more common <code>OPTIONS</code>:</p>"},{"location":"08_editing_files/#-isuffix-in-placesuffix","title":"<code>-i[SUFFIX]</code>/<code>--in-place[SUFFIX]</code>","text":"<p>This is one of the more vital options, and will often be used alongside others. It allows you to edit files in place, and can also make a backup of the file before creating a change if given the optional <code>SUFFIX</code>. Without including <code>-i</code>, this option will simply print what the given lines would look like if they were edited.</p> <p>Let's say we want to make an edit to our <code>planets.csv</code> file to have more explicit column names. Let's edit the title \"Planets\" to instead be \"Planet Names\" while also creating a <code>.bak</code> backup version of the file. <code>sed</code> can accomplish this with the expression:</p> <pre><code>sed -i.bak 's/Planet/Planet Name/' ./local-universe/milky-way/planets.csv\n</code></pre> <p>After running this, you will then have a new file named <code>planets.csv.bak</code> with the original version of the file, while the change \"Planet\" \\(\\to\\) \"Planet Name\" will be reflected in <code>planets.csv</code>.</p> <p>NOTE: It is not allowed to stack options after <code>-i</code>. Attempting to would simply result in the characters being appended to the end of the file. Multiple options can still be chosen or even stacked after <code>-i</code>, but must be separated with a space in order to not be treated as a suffix. </p>"},{"location":"08_editing_files/#-n-quiet-silent","title":"<code>-n</code>/<code>--quiet</code>/<code>--silent</code>","text":"<p>This option supresses the automatic printing of duplicate rows which can be generated by other flags. If used with the <code>/p</code> flag, this option will print only the targeted lines. Let's say you want to preview an edit to <code>galaxies.csv</code> where it is more explicit with the column names, changing \"Types\" to \"Galaxy Types\". You could run:</p> <pre><code>sed -n 's/Type/Galaxy Type/p' ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>Galaxy, Constellation, Galaxy Type,\n</code></pre> <p>NOTE: If you tried to add <code>-i</code> to this expression, it would result in a file that contains only the output line. To edit the line in the file, you would want to remove both <code>-n</code> and <code>/p</code>.</p>"},{"location":"08_editing_files/#-e-script-expressionscript","title":"<code>-e script</code>/<code>--expression=script</code>","text":"<p>These options allow for us to chain together multiple expressions. Let's say we want to convert the units of the planet radii from <code>m</code> to <code>km</code>. As the planets are all expressed with a radius of either \\(x \\times 10^6\\)m (xE6) or \\(x \\times 10^7\\)m (xE7), we could run the following three expressions to make this change:</p> <pre><code>sed -i -e 's/(m)/(km)/' -e 's/E6/E3/g' -e 's/E7/E4/g' ./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"08_editing_files/#-f-script-file-filescript-file","title":"<code>-f script-file</code>/<code>--file=script-file</code>","text":"<p>Instead of using <code>-e</code>, we can instead create a script file to read commands. This can be useful for when the number of edits you're trying to make would be cumbersome to type out directly in the command line. Let's say we want to represent the mass of all of the planets in tons instead of kilograms (1000 Kg = 1T). We can create a file and fill it with the relevant replacement commands:</p> <pre><code>nano kilogram-replacement.txt\n</code></pre> <pre><code>s/(Kg)/(T)/\ns/E23/E20/g\ns/E24/E21/g\ns/E25/E22/g\ns/E26/E23/g\ns/E27/E24/g\n</code></pre> <p>We can then run the expression:</p> <pre><code>sed -i -f kilogram-replacement.txt ./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"08_editing_files/#-e-r-regexp-extended","title":"<code>-E</code>/<code>-r</code>/<code>--regexp-extended</code>","text":"<p>These allow for the use of extended regular expressions.</p>"},{"location":"08_editing_files/#-s-separate","title":"<code>-s</code>/<code>--separate</code>","text":"<p>These allow for you to use multiple input files while also treating them as separate inputs. Without it, multiple input files can still be used, but will be treated as one longer stream.</p> <pre><code>sed -n -s '/Leo/p' ./local-universe/galaxies.csv ./local-universe/milky-way/constellations.csv\n</code></pre> <p>Output:</p> <pre><code>Leo A, Leo, Irregular\nLeo, Regulus,\n</code></pre>"},{"location":"08_editing_files/#using-ed","title":"Using <code>ed</code>","text":"<p>The <code>ed</code> line editor was one of the three original elements of the Unix system (assembler, editor, and shell), and can be used as a more surgical tool for editing files line-by-line. It's especially useful when you know or can find out the exact line numbers you wish to edit or when you want to script out precise edits. For most purposes however, <code>ed</code> is less useful than text-editors such as <code>nano</code> or <code>vim</code>, but it can be very efficient for specific uses with enough planning and forethought.</p> <p>Editing with <code>ed</code> is accomplished in two distinct modes: command and input. </p> <p>Command mode is the default mode when <code>ed</code> is initially invoked. From here, commands are read from the standard input and executed to manipulate the contents of the file. All commands operate on whole lines or ranges of lines. </p> <p>You can then enter input mode by inputting a command, such as <code>a</code> (append), <code>i</code> (insert), <code>d</code> (delete), or <code>c</code> (change). No commands are available after entering input, and input mode can then be terminated by entering a single period (<code>.</code>) on its own line.</p> <p>The format for running <code>ed</code> follows:</p> <pre><code>ed [OPTIONS] [[line] file]\ned [OPTIONS] [[line] '!command [arguments]']\n</code></pre> <p>NOTE: If the given <code>file</code> starts with a <code>!</code>, then it is interpreted as a shell command, meaning it will read the standard output of the <code>file</code> as if it was executed via the shell. If the file's name begins with a <code>!</code> then (and doesn't contain commands you want to run), simply prefix the name with <code>./</code>. </p>"},{"location":"08_editing_files/#addressing-lines-in-ed","title":"Addressing Lines in <code>ed</code>","text":"<p>The file name can also be preceded by <code>line</code> to set the current line to a specified line number (such as <code>1</code>). This will default to the last line if the number given exceeds the number of lines in the file. It is also important to note that <code>ed</code> indexes lines starting from <code>1</code> instead of <code>0</code>.</p> <p>The <code>file</code> may also be preceded by <code>/re</code> instead of the line number in order to set the current line as the first line which matches a given regular expression, <code>re</code>. <code>?re</code> sets the current line to the final line which matches the given regular expression.</p> <p>To summarize, most <code>ed</code> commands operate on <code>line</code> addresses. These can look like:</p> <ul> <li> <p>A specific line number: <code>5</code></p> </li> <li> <p>A range of lines: <code>1,5</code></p> </li> <li> <p>The current line: <code>.</code></p> </li> <li> <p>The last line: <code>$</code></p> </li> <li> <p>Relative lines: <code>.-1</code>, <code>.+2</code></p> </li> <li> <p>A regex match: <code>/pattern/</code> (forward), <code>?pattern?</code> (backwards)</p> </li> </ul>"},{"location":"08_editing_files/#basic-commands","title":"Basic Commands","text":"Command Meaning <code>a</code> Append text after current line <code>i</code> Insert text before current line <code>d</code> Delete current line <code>p</code> Print current line <code>w</code> Write the buffer to a file <code>q</code> Quit the editor ### Interacting with a file Let's try to make some changes again to our <code>planets.csv</code> file. To begin, simply type <code>ed</code> followed by the file path: <pre><code>ed ./local-universe/milky-way/planets.csv\n</code></pre> <p>Output:</p> <pre><code>288\n</code></pre> <p>In this output, <code>ed</code> is telling us that it has read 288 characters into the editor buffer. Now, we can print out all of the lines of the file by running:</p> <pre><code>,p\n</code></pre> <p>Here, <code>,</code> is the line range address, and is equivalent to typing <code>1,$</code>, meaning \"from the first line to the last line\". The <code>p</code> then is the command: print the specified lines. Output:</p> <pre><code>Planet, Radius (km), Distance (AU), Mass (T),\nMercury, 2.44E3, 0.39, 3.29E20,\nVenus, 6.05E3, 0.72, 4.87E21,\nEarth, 6.37E3, 1, 5.97E21,\nMars, 3.39E3, 1.52, 6.42E20,\nJupiter, 7.15E4, 5.2, 1.90E24,\nSaturn, 6.03E4, 9.54, 5.69E23,\nUranus, 2.56E4, 19.2, 8.68E22,\nNeptune, 2.48E4, 30.1, 1.02E23\n</code></pre> <p>Now let's say we want to edit the file to change some of the Roman planet names to be their Greek counterparts and then print our changes. We can do this using similar commands to <code>sed</code>:</p> <pre><code>2s/Mercury/Hermes/\n3s/Venus/Aphrodite/\n5s/Mars/Ares/\n6s/Jupiter/Zeus/\n,p\n</code></pre> <p>Output:</p> <pre><code>Planet, Radius (km), Distance (AU), Mass (T),\nHermes, 2.44E3, 0.39, 3.29E20,\nAphrodite, 6.05E3, 0.72, 4.87E21,\nEarth, 6.37E3, 1, 5.97E21,\nAres, 3.39E3, 1.52, 6.42E20,\nZeus, 7.15E4, 5.2, 1.90E24,\nSaturn, 6.03E4, 9.54, 5.69E23,\nUranus, 2.56E4, 19.2, 8.68E22,\nNeptune, 2.48E4, 30.1, 1.02E23\n</code></pre> <p>Now let's say we want to make an addition to the file - let's add the dwarf planets Ceres and Pluto:</p> <pre><code>5a\nCeres, 469.7, 2.77, 9.3839E17\n.\nPluto, 1.19E3, 49.3, 1.3E19,\n</code></pre> <p>Let's also be sure to add a <code>,</code> to the end of Neptune's line:</p> <pre><code>10s/$/,/\n</code></pre> <p>Now we can check our work again by running <code>,p</code>:</p> <pre><code>Planet, Radius (km), Distance (AU), Mass (T),\nHermes, 2.44E3, 0.39, 3.29E20,\nAphrodite, 6.05E3, 0.72, 4.87E21,\nEarth, 6.37E3, 1, 5.97E21,\nAres, 3.39E3, 1.52, 6.42E20,\nCeres, 469.7, 2.77, 9.38E17,\nJupiter, 7.15E4, 5.2, 1.90E24,\nSaturn, 6.03E4, 9.54, 5.69E23,\nUranus, 2.56E4, 19.2, 8.68E22,\nNeptune, 2.48E4, 30.1, 1.02E23,\nPluto, 1.19E3, 49.3, 1.3E19,\n</code></pre> <p>Now we can save our work and exit <code>ed</code> by writing the changes to our file and quiting:</p> <pre><code>w\nq\n</code></pre>"},{"location":"08_editing_files/#ed-vs-sed","title":"<code>ed</code> vs. <code>sed</code>","text":"<p>While <code>sed</code> is often the default choice for stream-based editing, there are several reasons you might choose to use <code>ed</code> over <code>sed</code>, especially in scripting, controlled environments, or low-resource systems.</p>"},{"location":"08_editing_files/#full-file-context","title":"Full File Context","text":"<p><code>sed</code> processes input line-by-line and can't refer back to previous lines or look ahead to future ones. In contrast, <code>ed</code> loads the entire file into a buffer and lets you operate on arbitrary lines or ranges. This makes <code>ed</code> more useful for edits which depend on file structure or relationships between lines.</p>"},{"location":"08_editing_files/#precise-scriptable-line-oriented-editing","title":"Precise, Scriptable, Line-Oriented Editing","text":"<p>When you know the exact lines you want to manipulate, such as in system-generated files, templates, or structured outputs, <code>ed</code> scripts can be extremely short and direct.</p>"},{"location":"08_editing_files/#minimal-dependencies","title":"Minimal Dependencies","text":"<p><code>ed</code> is tiny and often present on rescue systems, embedded Linux distros, or initramfs environments. If you're in a minimal shell or bootstrapping a system without <code>awk</code>, <code>sed</code>, or <code>vim</code>, <code>ed</code> may be the only editor available.</p> <p>Now that we have a basic understanding of using <code>sed</code> and <code>ed</code>, let's learn one of the most important tools for effectively utilizing them.Click here to continue on to the next section where we will learn how to create and execute shell scripts.</p>"},{"location":"09_shell_scripts/","title":"Shell Scripting","text":"<p>As the Unix shell is capable of using the contents of a file as input, it's possible to create a file with a list of commands which can then be executed by the shell. These files are called Shell Scripts or Shell Programs, and use the <code>.sh</code> file extension. Shell scripts work just like any other programming language, so having experience with other languages will make this section easier to understand and follow along with. Creating shell scripts can be useful for many applications, such as:</p> <ul> <li> <p>Routing backups of files</p> </li> <li> <p>Adding new functionality to the shell</p> </li> <li> <p>Automating work and repitition, etc</p> </li> </ul> <p>Fortunately, the commands and syntax for shell scripting are the same as those entered directly in the command line, so this entire lesson so far can be applied directly in shell scripts.</p>"},{"location":"09_shell_scripts/#creating-your-first-shell-script","title":"Creating Your First Shell Script","text":"<p>To begin, create a file ending in <code>.sh</code>, such as <code>hello.sh</code>:</p> <pre><code>touch hello.sh\n</code></pre>"},{"location":"09_shell_scripts/#bash-bangshebang","title":"Bash Bang/Shebang","text":"<p>In order to tell the system to use the shell to interpret the commands, you'll have to start the file with a bash bang/shebang (a combination of <code>bash #</code> and <code>bang !</code>, followed by the bash shell path). </p> <p>The path can vary, so before we start working on our <code>.sh</code> file, you'll want to confirm the path to your bash shell with:</p> <pre><code>which bash\n</code></pre> <p>Output:</p> <pre><code>/usr/bin/bash\n</code></pre> <p>Now you can open your script with:</p> <pre><code>nano hello.sh\n</code></pre> <p>And add your shebang line along with some commands:</p> <pre><code>#! /usr/bin/bash\n\necho \"Hello, world!\"\n</code></pre> <p>You can then save and close the file.</p>"},{"location":"09_shell_scripts/#execution-rights","title":"Execution rights:","text":"<p>In order to be able to actually treat the file as an executable, you'll have to modify the file's permissions. Users are able to have read, write, or execute (<code>rwx</code>) rights for files. To add execution rights for this file, you can run:</p> <pre><code>chmod +x hello.sh\n</code></pre> <p>You should now be able to execute the file by running:</p> <pre><code>./hello.sh\n</code></pre> <p>Output:</p> <pre><code>Hello, world!\n</code></pre>"},{"location":"09_shell_scripts/#shell-scripting-syntax","title":"Shell Scripting Syntax","text":"<p>Like other programming languages, shell scripting allows for the definition of variables, user input, for and while loops, arithmetic expressions, logical operators, conditionals, and loops. Let's take a look at some examples of each of these.</p>"},{"location":"09_shell_scripts/#variables","title":"Variables","text":"<p>Variables can be defined with <code>variable_name=value</code>. Note that bash does not allow for spaces between the variable name, equals sign, and the value. </p> <p>To access the value in a later call, add <code>$</code> before the variable name.</p> <p>Let's create a new file and start filling it with examples as we learn them:</p> <pre><code>nano examples.sh\n</code></pre> <pre><code>#! /usr/bin/bash\ngreeting=Hello\nsubject=World\necho \"$greeting, $subject!\"\n</code></pre> <p>You can then save this file and make it executable using the <code>chmod +x</code> command from before to give it a try. From here on, feel free to edit <code>examples.sh</code> using the <code>nano</code> command as you see fit, such as by appending the new examples to the end of the file or by deleting the previous example. </p>"},{"location":"09_shell_scripts/#arithmetic","title":"Arithmetic","text":"<p>Bash supports the following operators for mathmatic arithmetic: | Operator | Use            | |---       |---             | | <code>**</code>     | Exponentiation | | <code>*</code>      | Multiplication | | <code>/</code>      | Division       | | <code>+</code>      | Addition       | | <code>-</code>      | Subtraction    | | <code>%</code>      | Modulus        | Storing expressions in variables uses the syntax of:</p> <pre><code>var=$((expression))\n</code></pre> <p>It's also important to note that while writing equations in bash, it is mandatory to put a space between the value and the operator (<code>a + b</code> instead of <code>a+b</code>). Let's try out some examples by setting some numbers to variables and performing some calculations.</p> <pre><code>a=100\nb=5\nc=$((a / b))\nd=$((c ** b))\ne=$((d % a))\necho \"c=$c, d=$d, e=$e\"\n</code></pre> <p>Output:</p> <pre><code>c=20, d=3200000, e=0\n</code></pre> <p>By default, bash only returns integer values. In order to return floating point values it is necessary to use another tool such as <code>bc</code>. You can install <code>bc</code> with the command:</p> <pre><code>sudo apt install bc\n</code></pre> <p>Then you can add to <code>examples.sh</code>:</p> <pre><code>f=$(echo \"scale=5; 22 / 7\" | bc)\necho $f\n</code></pre> <p>(<code>scale</code> specifies the number of decimal places to return in the output.) Output:</p> <pre><code>3.14285\n</code></pre>"},{"location":"09_shell_scripts/#user-inputs","title":"User Inputs","text":"<p>It is possible to take user input using the <code>read</code> command. To prompt the user with a custom message for user input, you can pair <code>read</code> with the <code>-p</code> flag. Let's say we want to create a very rudimentary calculator with user input. To our <code>examples.sh</code> file, we can add:</p> <pre><code>read -p \"Enter the first number. \" first_number\nread -p \"Enter the second number. \" second_number\nadd_values=$((first_number + second_number))\necho \"$first_number + $second_number = $add_values\"\n</code></pre> <p>Output:</p> <pre><code>Enter the first number. 10\nEnter the second number. 15\n10 + 15 = 25\n</code></pre>"},{"location":"09_shell_scripts/#conditionals","title":"Conditionals","text":"<p>Conditonal statements in bash have two componenets: a conditional statement and one or more conditional operators.</p>"},{"location":"09_shell_scripts/#conditional-statements","title":"Conditional Statements","text":"<p>There are 5 available conditional statements available in bash programming, using combinations of <code>if</code>, <code>then</code>, <code>elif</code>, or <code>else</code>, as well as switch statements using <code>case</code>. </p> <ol> <li><code>if</code></li> </ol> <pre><code>if [ expression ]\nthen\n    statement\nfi\n</code></pre> <p>This block will run the statement if the expression is evaluated as true.</p> <ol> <li><code>if-else</code></li> </ol> <pre><code>if [ expression ]\nthen\n    statement1\nelse\n    statement2\nfi\n</code></pre> <p>If the first expression is true, the first statement will run, otherwise the second statement will.</p> <ol> <li>Else If ladder</li> </ol> <pre><code>if [ expression1 ]\nthen\n    statement1\n    statement2\nelif [ expression2 ]\nthen\n    statement3\n    statement4\nelse\n    statement5\nfi\n</code></pre> <p>This allows for multiple conditions to be tested separately with different results depending on which of the expressions evaluates as true. If none evaluate as true, it would then run the <code>else</code> statement.</p> <ol> <li>Nested <code>if</code></li> </ol> <pre><code>if [ expression1 ]\nthen\n    statement1\n    statement2\nelse\n    if [ expression2 ]\n    then\n        statement3\n    fi\nfi\n</code></pre> <p>This allows you to check an initial condition, and then check for a second condition based on the results of the first. It is possible to nest an arbitrary number of conditons.</p> <ol> <li>Case statments With a <code>case</code> statement, you are able to match patterns condtionally and return different results depending on the match. After finding a match, all associated statements are executed until reaching a <code>;;</code>. If no match is found, the exit status of the case is set as zero.</li> </ol> <pre><code>case word in\n    \"var1\") statement1;;\n    \"var2\") statement2;;\n    \"var3\") statement3;;\nesac\n</code></pre>"},{"location":"09_shell_scripts/#conditional-operators","title":"Conditional Operators","text":"<p>There are several possible conditional operators that can be used to test numerical arguments, files, and strings. To test numerical arguments, you can reference the following table:</p> Operator Meaning <code>-eq</code> Equal to <code>-ne</code> Not equal to <code>-gt</code> Greater than <code>-ge</code> Greater than or equal to <code>-lt</code> Less than <code>-le</code> Less than or equal to <p>Click here for a complete list of bash operators and how to use them.</p>"},{"location":"09_shell_scripts/#logical-operators","title":"Logical Operators","text":"<p>Logical operators allow for you to combine or negate conditional expressions.</p> Operator Meaning Example <code>&amp;&amp;</code> Logical AND (both must be true) <code>[ $a -gt 5 ] &amp;&amp; [ $b -lt 10 ]</code> <code>\\|\\|</code> Logical OR (either can be true) <code>[ $a -lt 5 ] \\|\\| [ $b -eq 10 ]</code> <code>!</code> Logical NOT (negates condition) <code>! [ -f file.txt ]</code> <p>You can also group conditions using double square brackets and logical keywords:</p> <pre><code>if [[ $a -gt 5 &amp;&amp; $b -lt 10 ]]\nthen\n    echo \"Both conditions are true.\"\nfi\n</code></pre> <p>Or:</p> <pre><code>if [[ $name != \"admin\" || $level -lt 3 ]]\nthen\n    echo \"Access denied.\"\nfi\n</code></pre>"},{"location":"09_shell_scripts/#loops","title":"Loops","text":"<p>Bash supports several types of loops that allow for you to repeat a block of code until a condition is met or for each item in a list.</p>"},{"location":"09_shell_scripts/#for-loop","title":"<code>for</code> loop","text":"<p>The <code>for</code> loop iterates over a list of value:</p> <pre><code>for planet in Mercury Venus Earth Mars\ndo\n    echo \"Welcome to $planet\"\ndone\n</code></pre> <p>Output:</p> <pre><code>Welcome to Mercury\nWelcome to Venus\nWelcome to Earth\nWelcome to Mars\n</code></pre> <p>Bash also supports C-style syntax:</p> <pre><code>for (( i = 0; i &lt; 5; i++ ))\ndo\n    echo \"i is $i\"\ndone\n</code></pre> <p>Output:</p> <pre><code>i is 0\ni is 1\ni is 2\ni is 3\ni is 4\n</code></pre>"},{"location":"09_shell_scripts/#while-loop","title":"<code>while</code> loop","text":"<p>The <code>while</code> loop runs as long as a specified condition is true:</p> <pre><code>count=1\nwhile [ $count -le 5 ]\ndo\n    echo \"Count is $count\"\n    ((count++))\ndone\n</code></pre> <p>Output:</p> <pre><code>Count is 1\nCount is 2\nCount is 3\nCount is 4\nCount is 5\n</code></pre>"},{"location":"09_shell_scripts/#until-loop","title":"<code>until</code> loop","text":"<p>The <code>until</code> loop runs until the condition becomes true - the opposite of a <code>while</code> loop:</p> <pre><code>count=1\nuntil [ $count -gt 5 ]\ndo\n    echo \"Count is $count\"\n    ((count++))\ndone\n</code></pre> <p>Output:</p> <pre><code>Count is 1\nCount is 2\nCount is 3\nCount is 4\nCount is 5\n</code></pre>"},{"location":"09_shell_scripts/#break-and-continue","title":"<code>break</code> and <code>continue</code>","text":"<ul> <li> <p><code>break</code> exits the loop entirely.</p> </li> <li> <p><code>continue</code> skips the current iteration and moves to the next.</p> </li> </ul> <pre><code>for i in {1..10}\ndo\n    if [ $i -eq 4 ]\n    then\n        continue\n    elif [ $i -eq 8 ]\n    then\n        break\n    fi\n    echo $i\ndone\n</code></pre> <p>Output:</p> <pre><code>1\n2\n3\n5\n6\n7\n</code></pre> <p>Now that we have a basic understanding of the syntax of shell scripting, let's try putting it to use using our example files. Click here to continue on to the next section where we'll put this lesson to work with a shell script.</p>"},{"location":"10_script_example/","title":"Scripting Example","text":"<p>We've now learned how to use the Unix shell to navigate our folder system, to create and delete files, create and delete folders, copy, move, and rename files and folders, to search for and inside of files, how to edit the contents of files, and finally how to create and run shell scripts to automate any and all of these processes. Let's try now to put together some of these abilities of the Unix shell and create a script to manipulate the contents of our <code>Unix-Tips</code> folder. If you've been following along with the examples provided in this lesson, your folder tree should look similar to:</p> <pre><code>\u251c\u2500\u2500 csv_list.txt\n\u251c\u2500\u2500 examples.sh\n\u251c\u2500\u2500 exclude-pattern.txt\n\u251c\u2500\u2500 hello.sh\n\u251c\u2500\u2500 kilogram-replacement.txt\n\u251c\u2500\u2500 local-universe\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 galaxies.csv\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 milky-way\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 constellations.csv\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 planets.csv\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 planets.csv.bak\n\u2514\u2500\u2500 pattern.txt\n\n2 directories, 10 files\n</code></pre> <p>In order to demonstrate some ways we can use shell scripts to edit files and folders, let's say that we want to create a script to accomplish the following goals with the contents of this folder:</p> <ol> <li> <p>Delete all of the <code>.txt</code> files</p> </li> <li> <p>Restore the original version of <code>planets.csv</code></p> </li> <li> <p>Move <code>planets.csv</code> into a new <code>solar-system</code> folder</p> </li> <li> <p>Change uppercase characters to lowercase for all <code>.csv</code> files.</p> </li> </ol> <p>Let's name our new script <code>reformat-folder.sh</code>:</p> <pre><code>nano reformat-folder.sh\n</code></pre> <p>NOTE: When first creating a code it's useful to print statements (using <code>echo</code> for shell) for every step. This is makes it easier to find at what step an error occurs if you run into one.</p> <pre><code>#! /usr/bin/bash\n\n# Set existing folders as variables for easier use\nlocal_dir=\"./local-universe/\"\ngalaxy_dir=$local_dir\"milky-way/\"\n\n# Delete all .txt files\necho \"Deleting .txt files...\"\nfind . -type f -name \"*.txt\" -delete\n\n# Forcefully overwrite planets.csv with the backup\necho \"Restoring file from backup...\"\nsrc=$galaxy_dir\"planets.csv.bak\"\ndest=$galaxy_dir\"planets.csv\"\ncp -f \"$src\" \"$dest\"\n# Note: quoting variable names for paths is useful if the path contains spaces\n\n# Create a new folder for planets.csv\necho \"Creating new folder...\"\nsolar_dir=$galaxy_dir\"solar-system/\"\nmkdir -p \"$solar_dir\"\n\n# Move planets.csv into the new folder\necho \"Moving planets.csv...\"\nsrc2=$galaxy_dir\"planets.csv\"\ndest2=$solar_dir\"planets.csv\"\nmv \"$src2\" \"$dest2\"\n\n# Delete .bak file\necho \"Deleting planets.csv.bak...\"\nbak_path=$galaxy_dir\"planets.csv.bak\"\nrm \"$bak_path\"\n\n# Loop through all .csv files and make everything lowercase\necho \"Creating lowercase versions of all .csv files...\"\nfind local-universe/ -type f -name \"*.csv\" | while read -r csv_file; do\n    # Extract base name and directory\n    dir_name=$(dirname \"$csv_file\")\n    base_name=$(basename \"$csv_file\" .csv)\n\n    # Define lowercase output filename\n    out_file=\"${dir_name}/${base_name}-lowercase.csv\"\n\n    # Check if file is not already lowercase version\n    if [[ ! \"$csv_file\" =~ lowercase\\.csv$ ]]; then\n        echo \" Changing case: $csv_file -&gt; $out_file\"\n        tr '[:upper:]' '[:lower:]' &lt; \"$csv_file\" &gt; \"$out_file\"\n    fi\ndone\n\n# Optional: Delete all non-lowercase versions of the files\necho \"Deleting original .csv files...\"\nfor file in $(find . -type f -name \"*.csv\"); do\n    if [[ \"$file\" != *-lowercase.csv ]]; then\n        echo \"Deleting $file\"\n        rm \"$file\"\n    fi\ndone\n\necho \"Script complete!\"\n</code></pre> <p>Output:</p> <pre><code>Deleting .txt files...\nRestoring file from backup...\nCreating new folder...\nMoving planets.csv...\nDeleting planets.csv.bak...\nCreating lowercase versions of all .csv files...\n Changing case: local-universe/galaxies.csv -&gt; local-universe/galaxies-lowercase.csv\n Changing case: local-universe/milky-way/constellations.csv -&gt; local-universe/milky-way/constellations-lowercase.csv\n Changing case: local-universe/milky-way/solar-system/planets.csv -&gt; local-universe/milky-way/solar-system/planets-lowercase.csv\nDeleting original .csv files...\nDeleting ./local-universe/galaxies.csv\nDeleting ./local-universe/milky-way/constellations.csv\nDeleting ./local-universe/milky-way/solar-system/planets.csv\nScript complete!\n</code></pre> <p>You can then double check the script's work by running <code>tree</code>:</p> <p>Output</p> <pre><code>\u251c\u2500\u2500 examples.sh\n\u251c\u2500\u2500 hello.sh\n\u251c\u2500\u2500 local-universe\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 galaxies-lowercase.csv\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 milky-way\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 constellations-lowercase.csv\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 solar-system\n\u2502\u00a0\u00a0         \u2514\u2500\u2500 planets-lowercase.csv\n\u2514\u2500\u2500 reformat-folder.sh\n</code></pre>"},{"location":"10_script_example/#wrapping-up","title":"Wrapping up","text":"<p>This short and simple script demonstrates some of the utility of the Unix shell when paired with scripting. A few lines of code allowed us to clean up files, restore backups, reorganize folders, and transform file contents, all automatically. While the script we wrote here is specific to the structure of this lesson, the techniques used here are widely applicable to any kind of filesystem or data maintenance task.</p> <p>With careful use of conditionals, loops, and external tools, we can build reliable, repeatable processes that can save time and reduce human error. This is the core strength of Unix: simple commands that combine into powerful tools. As you continue learning, try experimenting with your own scripts to automate parts of your workflow and explore what the shell has to offer.</p>"}]}