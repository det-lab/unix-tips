{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md                     # The documentation homepage.\n    01_summary_and_setup.md      # Introduction\n    02_navigation.md             # Tips for navigating file system\n    03_command_history.md        # Tips for utilizing command history\n    04_file_operations.md        # Tips for organizing files\n    05_creating_example_files.md # Creating files for examples\n    06_searching_for_files.md    # Tips on how to search for files\n    07_searching_inside_files.md # Tips on searching for content inside files\n</code></pre>"},{"location":"01_summary_and_setup/","title":"Summary","text":"<p>The Unix shell is more than just a way to launch programs: it's a powerful environment for automating tasks, managing files, and interacting with your system efficiently. Whether you're using <code>bash</code>, <code>zsh</code>, or another variant, the shell can become a highly personalized and productive workspace once you know how to use it effectively. </p> <p>In this short series of lessons, we'll cover practical tips and time-saving techniques for working in the shell such as shortcuts for navigating directories, command history, file operations, search and substitution tricks, interpreting the UI colors, customization options, and more. </p>"},{"location":"01_summary_and_setup/#install-software","title":"Install Software","text":"<p>If you do not already have it installed, click this link for instructions on how to download and install the Bash shell for Windows, MacOS, or Linux. </p> <p>Click here to continue to the next section where we will go over tips for navigating directories with the Unix shell.</p>"},{"location":"02_navigation/","title":"Navigation","text":"<p>Before you can manage files and run scripts, it's necessary to understand and be comfortable with moving around your system from inside the shell. The Unix shell provides flexible commands for exploring the directory structure. This section will cover tips and common patterns for navigation that will save you time and help prevent mistakes.</p>"},{"location":"02_navigation/#basic-commands","title":"Basic Commands","text":"<ul> <li> <p><code>pwd</code>: Print Working Directory. This command gives a print out of the path to reach the directory you're currently working from. For instance, if you're opening Linux, <code>pwd</code> might return a path like: <code>/home/userName</code></p> </li> <li> <p><code>ls</code>: List. This command shows the contents of the current directory. </p> </li> <li> <p><code>cd &lt;directory&gt;</code>: Change Directory. This command allows you to move into a different folder.</p> </li> </ul> <p>You can also use <code>ls &lt;directory&gt;</code> or <code>ls &lt;path&gt;</code> to show the contents of a folder other than the one you're currently in. </p>"},{"location":"02_navigation/#useful-shortcuts","title":"Useful Shortcuts","text":"<ul> <li> <p><code>~</code> represents your home directory path, so <code>cd ~</code> will change your directory to the top of your folder tree and <code>ls ~</code> will show you same folder's contents.</p> </li> <li> <p><code>cd -</code> will return you to the previous directory you were in.</p> </li> <li> <p><code>.</code> refers to the current directory.</p> </li> <li> <p><code>..</code> refers to the parent directory, so <code>cd ..</code> will move you into the parent directory and <code>ls ..</code> will show the contents of the parent directory.</p> </li> </ul>"},{"location":"02_navigation/#tab-completion","title":"Tab Completion","text":"<p>You can start typing a directory or file name and press <code>Tab</code> to auto-complete. If multiple matches exist, pressing <code>Tab</code> twice will show you the options. This also works inside of different directories, meaning you can use <code>Tab</code> for each directory to shorten how much is needed to type to navigate deeper into a path. For instance:</p> <pre><code>cd Doc&lt;tab&gt;/Git&lt;tab&gt;/\n</code></pre> <p>would move you into the <code>Documents/Github</code> folder. </p> <p>Tab completion works slightly differently in different shells. <code>Powershell</code> and <code>Fish</code> are not case sensitive, while <code>Bash</code> and <code>Tcsh</code> are.</p>"},{"location":"02_navigation/#listing-files-more-effectively","title":"Listing Files More Effectively","text":"<p>There are several options that can be added after <code>ls</code> to modify its behavior. For a complete list, you can use <code>ls --help</code>. It's also important to note that it is possible to use different modifiers together for more comprehensive results. </p> <p>For instance, <code>-a</code> will show all files, including hidden ones such as dotfiles like <code>.gitignore</code>, while <code>-A</code> will show almost all files, ignoring <code>.</code> and <code>..</code> entries. <code>-l</code> will use a long listing format, <code>-h</code> will use a human readable format, <code>-r</code> will reverse the result order, and <code>-t</code> will sort by modified time. Stacking these options together allows for searches such as:</p> <pre><code>ls -lh # Long listing format with human-readable file sizes\nls -ltr # Long listing format, sort by modified time, oldest first\nls -Alh # Show almost all files, long listing format, human readable\n</code></pre>"},{"location":"02_navigation/#using-tree-for-a-visual-directory-structure","title":"Using <code>tree</code> for a Visual Directory Structure","text":"<p>The <code>tree</code> command visually maps directory structures, making it especially helpful when you need to understand the organization of nested directories, showing you directories without requiring you to manually navigate through each one. </p> <p>By default, <code>tree</code> is not installed, but it can be installed with the commands:</p> <pre><code>sudo yum install tree\n</code></pre> <p>or</p> <pre><code>sudo dnf install tree\n</code></pre> <p>For RHEL, CentOS, and Fedora Linux.</p> <pre><code>sudo apt-get install tree\n</code></pre> <p>For Debian, Mint, and Ubuntu Linux.</p> <pre><code>brew install tree\n</code></pre> <p>For Apple OS X.</p>"},{"location":"02_navigation/#basic-syntax-of-tree-command","title":"Basic Syntax of Tree Command","text":"<p>Just entering <code>tree</code> by itself will output your entire file structure starting from your current directory, making it not very useful without applying certain condtions. The basic command syntax is to use <code>tree [options]</code> for more precise usage. As before, you can enter <code>tree --help</code> in order to see a list of all options. </p> <p>A short list of options you might use more often include:</p> <ul> <li> <p><code>-a</code> or <code>--all</code>: Includes hidden files and directories in the tree.</p> </li> <li> <p><code>-d</code> or <code>--dirs-only</code>: List directories only.</p> </li> <li> <p><code>-f</code> or <code>--full-path</code>: Prints the full path prefix for each file.</p> </li> <li> <p><code>-p</code> or <code>--prune</code>: Omits specified directory from the tree.</p> </li> <li> <p><code>--filelimit #</code>: Doesn't descend directories that contain more than # entries.</p> </li> <li> <p><code>-s</code>: Prints the size of each file along with the name.</p> </li> <li> <p><code>-L #</code>: Sets a maximum depth, #, of the directory tree to display.</p> </li> </ul> <p>As before, these can also be mixed and matched. For instance, if you only wanted to visualize directories up to 3 folders deep and you also wanted to see the path for each file, you could run:</p> <pre><code>tree -dpL 3\n</code></pre> <p>Now that you're familiar with moving around and inspecting the filesystem, let's look at how you can save time using command history and quick recall tools. Click here to continue on to the next section.</p>"},{"location":"03_command_history/","title":"Command History and Quick Recall Tools","text":"<p>Typing the same long commands over and over can get tedious and error prone. Fortunately, Unix shells keep a command history that lets you easily recall, repeat, and modify previous commands. This section covers essential shortcuts and tools to speed up your workflow.</p>"},{"location":"03_command_history/#basic-history-navigation","title":"Basic History Navigation","text":"<ul> <li> <p>Press the up arrow to scroll through previous commands.</p> </li> <li> <p>Press the down arrow to move forward again.</p> </li> </ul> <p>You can also view a full numbered history of your previous commands with:</p> <pre><code>history\n</code></pre>"},{"location":"03_command_history/#search-through-command-history","title":"Search Through Command History","text":"<p>You can use reverse search to find previous commands be substring. From the shell, press <code>CTRL+R</code> to begin a reverse search. You can then start typing part of the command, and the shell will search backward through your history.</p> <ul> <li> <p>Keep pressing <code>CTRL+R</code> to cycle through more matches.</p> </li> <li> <p>Press <code>Enter</code> to run the found command.</p> </li> <li> <p>Press <code>Esc</code> or <code>CTRL+G</code> to cancel the search.</p> </li> </ul> <p>Tip: Use <code>CTRL+S</code> to search forward</p>"},{"location":"03_command_history/#repeating-previous-commands-with-fish","title":"Repeating Previous Commands with Fish","text":"<p>The Fish shell offers even more intuitive and powerful history navigation tools. You can download Fish by following this link to the official site, or in Unix, you can run the command:</p> <pre><code>sudo apt install fish\n</code></pre> <p>Once installed, you only need to enter <code>fish</code> into your current shell to try it out. </p> <p>With the Fish shell, you're able to start typing any part of a previous command, and the shell will automatically suggest matching commands from your history. You can then press the up arrow to cycle through earlier commands, or press the right arrow to accept the suggestion, and then press Enter to run the command.</p> <p>Fish also includes advanced history commands:</p> <ul> <li> <p><code>history search &lt;pattern&gt;</code> shows matching commands.</p> </li> <li> <p><code>history delete --prefix &lt;pattern&gt;</code> deletes entries from your history that start with a given prefix.</p> </li> </ul> <p>Note: Fish keeps history per session and per working directory, making it especially useful for project-based work.</p> <p>Fish also helpfully uses syntax highlighting as you type. For instance, by default, Fish will color invalid commands red as you write them, and underline valid file paths.</p>"},{"location":"03_command_history/#view-and-edit-commands-before-running","title":"View and Edit Commands Before Running","text":"<p>You can use <code>fc</code> (fix command) to open your previous command in your default editor, such as <code>nano</code>, <code>vim</code>, or <code>emacs</code>. This can be useful for making edits to long or complex commands before re-running them.</p> <p>Now that you can navigate and reuse your command history efficiently, we'll move on to file operations: copying, moving, renaming, and deleting files using the shell. Click here to continue on to the next section.</p>"},{"location":"04_file_operations/","title":"Working with Files: Copy, Move, and Remove","text":"<p>File operations are fundamental to using the Unix shell effectively. Whether you're managing project files, organizing backups, or scripting automation tasks, mastering a few essential commands can greatly streamline your workflow.</p>"},{"location":"04_file_operations/#creating-files-with-touch","title":"Creating files with <code>touch</code>","text":"<p>The <code>touch</code> command follows the basic format of:</p> <pre><code>touch [OPTION] FILE\n</code></pre> <p>The command updates the access and modification times of the selected file to the current time. It can also be used to create a new file if the <code>FILE</code> argument does not exist.</p>"},{"location":"04_file_operations/#useful-touch-options","title":"Useful <code>touch</code> Options","text":"<p>While there aren't options to influence the creation of a new file with <code>touch</code> (aside from not creating one using <code>-c</code> or <code>--no-create</code>), there are options to modify the access and modification times of an existing file, such as:</p> <ul> <li> <p><code>-a</code>: Change only the access time.</p> </li> <li> <p><code>-d [STRING]</code> or <code>--date=STRING</code>: Parse <code>STRING</code> and use it instead of the current time. </p> <p><code>STRING</code> must be in the format <code>[[CC]YY]MMDD</code>. If <code>YY</code> is specified but <code>CC</code> is not, a value for <code>YY</code> between 69 and 99 results in a <code>CC</code> value of 19. Otherwise, <code>CC</code> defaults to a value of 20. So, if you wanted to change the last modified date of a file to January 1st, 2018, you would use the command:</p> </li> </ul> <pre><code>touch -d 20180101 example.txt\n</code></pre> <ul> <li> <p><code>-h</code> or <code>--no-dereference</code>: This command affects symbolic links instead of referenced files.</p> </li> <li> <p><code>-m</code>: Changes the modification time to the current time.</p> </li> <li> <p><code>-t [STAMP]</code>: Parse a <code>STAMP</code> of the format <code>[[CC]YY]MMDDhhmm[.SS]</code> to be the new modification time.</p> <p>The same rules apply for the <code>[[CC]YY]MMDD</code> part of the argument. The <code>hh</code> argument uses a 24 hour clock (from 00 to 23). If you wished to change the modified date of a file to January 1st, 2018, at 5:28:30pm, you could use the command:</p> </li> </ul> <pre><code>touch -d 201801011728.30 example.txt\n</code></pre> <p>For more information on the basics of text editors which you can use to edit the contents of a file, you can follow this link to a short series of lessons on three of the most popular text editors, <code>nano</code>, <code>Vim</code>, and <code>Emacs</code>.</p>"},{"location":"04_file_operations/#making-folders-with-mkdir","title":"Making folders with <code>mkdir</code>","text":"<p>The <code>mkdir</code> command will create a new folder if one does not already exist. It follows the basic format of:</p> <pre><code>mkdir [OPTION] DIRECTORY\n</code></pre>"},{"location":"04_file_operations/#useful-mkdir-options","title":"Useful <code>mkdir</code> Options","text":"<ul> <li><code>-p</code> or <code>--parents</code>: Creates parent directories if necessary. For instance, running the following from a folder where <code>testdir</code> doesn't exist will create three total directories:</li> </ul> <pre><code>mkdir -p testdir/subdir/exampledir\n</code></pre> <ul> <li><code>-v</code>: Print a message for each created directory. This can be useful for automated scripts to show everything that gets created, potentially helping to find errors in directory creation.</li> </ul>"},{"location":"04_file_operations/#copying-files-with-cp","title":"Copying files with <code>cp</code>","text":"<p><code>cp</code> copies files or directories. The basic usage looks like:</p> <pre><code>cp [OPTION] SOURCE DEST\n</code></pre> <p>Where <code>SOURCE</code> and <code>DEST</code> would be the old and new filenames if you're copying the file to the same directory. For instance, if you're just copying a file to the same directory and changing its name, that would look like:</p> <pre><code>cp oldfile.txt backup.txt\n</code></pre> <p>You can also copy the original file into a new folder by setting <code>DEST</code> as the path, such as in:</p> <pre><code>mkdir testdir\ncp oldfile.txt testdir/\n</code></pre> <p>It is also possible to change the name of the copy in the same way:</p> <pre><code>cp oldfile.txt tesdir/backup.txt\n</code></pre>"},{"location":"04_file_operations/#useful-cp-options","title":"Useful <code>cp</code> Options","text":"<p>There are several common options to use with the copy command. These include:</p> <ul> <li> <p><code>-f</code> or <code>--force</code>: If an existing destination file cannot be opened, remove it and try again.</p> </li> <li> <p><code>-n</code> or <code>--no-clobber</code>: Prevents you from overwriting an existing file.</p> </li> <li> <p><code>-i</code> or <code>--interactive</code>: Prompts you for confirmation before overwriting an existing file.</p> </li> </ul> <p>Note that <code>-n</code> and <code>-i</code> will override each other. Only the second one will be used.</p> <ul> <li> <p><code>-R</code>, <code>-r</code>, or <code>--recursive</code>: Option required to copy a directory. </p> </li> <li> <p><code>-s</code> or <code>--symbolic-link</code>: Makes a symbolic link instead of copying the file. A symbolic link is similar to a shortcut, differing from copying in that changes to the original will effect the symbolic link version of the file as well, while copying creates an independant version of the file.</p> </li> </ul>"},{"location":"04_file_operations/#move-or-rename-files-with-mv","title":"Move or rename files with <code>mv</code>","text":"<p><code>mv</code> moves files if the target is a directory or renames them if the target includes a new name. This command differs from copying in that only one version of the file or directory is preserved. However the command is otherwise very similar, following the basic usage of:</p> <pre><code>mv [OPTION] SOURCE DEST\n</code></pre> <p>For instance, if you want to move a file to a new directory, you can use:</p> <pre><code>mv oldfile.txt testdir/\n</code></pre> <p>If you wish to rename it in the process:</p> <pre><code>mv oldfile.txt testdir/newname.txt\n</code></pre> <p>If you only wish to rename the file while keeping it in the same directory:</p> <pre><code>mv oldfile.txt newname.txt\n</code></pre>"},{"location":"04_file_operations/#useful-mv-options","title":"Useful <code>mv</code> Options","text":"<p>Some of the options are also the same as in the copy command, including:</p> <ul> <li> <p><code>-f</code>, <code>--force</code></p> </li> <li> <p><code>-i</code>, <code>--interactive</code>, and</p> </li> <li> <p><code>-n</code>, <code>--no-clobber</code></p> </li> </ul> <p>The other suggested options that are available in copy (<code>-R</code>, <code>-r</code>, <code>--recursive</code>, <code>-s</code>, and <code>--symbolic-link</code>) are not available for the <code>mv</code> command. </p>"},{"location":"04_file_operations/#delete-files-with-rm","title":"Delete files with <code>rm</code>","text":"<p><code>rm</code> deletes/unlinks files or folders, so use this option with caution. Its basic usage follows the format of:</p> <pre><code>rm [OPTION] FILE\n</code></pre> <p>Like with <code>cp</code> and <code>mv</code>, the <code>FILE</code> argument can be a path to a specific file outside of the directory that your shell is inside of.</p>"},{"location":"04_file_operations/#useful-rm-options","title":"Useful <code>rm</code> Options","text":"<ul> <li> <p><code>-f</code> or <code>--force</code>: Ignores nonexistent files and arguments.</p> </li> <li> <p><code>-i</code>: Prompts the user for confirmation before every removal.</p> </li> <li> <p><code>-I</code>: Prompts the user for confirmation if trying to remove more than three files, or when removing recursively. This is useful for automated scripts.</p> </li> <li> <p><code>-r</code>, -<code>R</code>, or <code>--recursive</code>: Remove directories and their contents.</p> </li> <li> <p><code>-d</code> or <code>--dir</code>: Removes empty directories.</p> </li> </ul>"},{"location":"04_file_operations/#destroy-files-with-shred","title":"Destroy files with <code>shred</code>","text":"<p><code>shred</code> is similar to <code>rm</code> in that it makes files unusable, but <code>shred</code> repeatedly overwrites the content, making it unrecoverable. Think of <code>rm</code> as like sending a file to your recycle bin, while <code>shred</code> is more like corrupting a file. It is still possible to recover files that have been removed with <code>rm</code> if you know what you're doing, but it is incredibly difficult to recover files that you <code>shred</code>, even using expensive hardware. Its basic usage follows the format of:</p> <pre><code>shred [OPTION] FILE\n</code></pre> <p>When you <code>shred</code> a file, there will still be a file with the given name and extension, but its contents will be unrecognizable. To demonstrate, try making an example file with a text editor:</p> <pre><code>nano example.txt\n</code></pre> <p>Then, write something to the file, save and quit (<code>CTRL+X</code> \\(\\to\\) <code>Y</code> \\(\\to\\) <code>Enter</code>), and <code>shred</code> the file.</p> <pre><code>shred example.txt\n</code></pre> <p>You can then run the command <code>nano example.txt</code> to open the file in your shell to see that your message has been transformed into a jumble of ASCII text.</p>"},{"location":"04_file_operations/#useful-shred-options","title":"Useful Shred Options","text":"<ul> <li> <p><code>-f</code> or <code>--force</code>: Changes permissions to allow writing to the file.</p> </li> <li> <p><code>-n</code> or <code>--iterations=N</code>: By default, <code>shred</code> will overwrite the file 3 times. This option allows you to specify how many times, N, to overwrite the file, making it potentially easier or more difficult to recover the data.</p> </li> <li> <p><code>-s</code> or <code>--size=N</code>: Allows you to specify a number, N, of bytes to overwrite.</p> </li> <li> <p><code>-u</code>: Remove file after overwriting it.</p> </li> <li> <p><code>-z</code> or <code>--zero</code>: Add a final overwrite with zeros to hide the shredding.</p> </li> </ul> <p>Now that you have a handle on creating, moving, and entering files and directories, click here to continue to the next section where we will discuss searching for files.</p>"},{"location":"05_creating_example_files/","title":"Creating Example Files","text":"<p>Now that we've gotten some of the more vital commands down, let's use this as an opportunity to start creating some files that we can test our command knowledge on. This section will show the explicit creation of the example files, but you can also simply download the three created files from here and move them to a chosen directory:</p> <ul> <li> <p>planets.md</p> </li> <li> <p>constellations.md</p> </li> <li> <p>galaxies.md</p> </li> </ul> <p>To create the files, first, navigate to a folder that you'd be willing to use to house some files for this lesson by using the <code>cd</code> command, such as:</p> <pre><code>cd ~\n</code></pre> <p>To navigate to the home directory. From there, create a new folder which can be used to house your example files:</p> <pre><code>mkdir Unix-Tips\n</code></pre> <p>You'll then want to enter this directory using:</p> <pre><code>cd Unix-Tips\n</code></pre> <p>Now, let's create and edit some files using the <code>touch</code> command and a text editor of your choice. This lesson will be using <code>nano</code>. We'll want to create some files that have several lines with distinct words or phrases for the later sections which will focus on editing and searching. For this example, we'll be creating a couple of files with astronomical data:</p> <pre><code>touch planets.md\ntouch constellations.md\ntouch galaxies.md\n</code></pre> <p>Let's start by creating our <code>planets.md</code> file. We'll create one line for each planet and include its radius, distance from the sun, and mass. Start by entering:</p> <pre><code>nano planets.md\n</code></pre> <p>Then, inside the file, we can add our information:</p> Planet Radius (m) Distance (AU) Mass (Kg) Mercury 2.44E6 0.39 3.29E23 Venus 6.05E6 0.72 4.87E24 Earth 6.37E6 1 5.97E24 Mars 3.39E6 1.52 6.42E23 Jupiter 7.15E7 5.2 1.90E27 Saturn 6.03E7 9.54 5.69E26 Uranus 2.56E7 19.2 8.68E25 Neptune 2.48E7 30.1 1.02E26 <p>Then save and exit the file using <code>CTRL+X</code> and <code>Y</code> before creating data for the second two files:</p> <pre><code>nano constellations.md\n</code></pre> <p>With data from the Zodiac constellations:</p> Constellation Brightest Star Aries Hamal Taurus Aldebaran Gemini Pollux Cancer Al Tarf Leo Regulus Virgo Spica Libra Zubeneschamali Scorpius Antares Ophiuchus Rasalhague Sagittarius Kaus Australis Capricornus Deneb Algedi Aquarius Sadalsuud Pisces Alpherg <p>And finally, let's fill galaxies.md with a small selection of galaxies in our local group:</p> <pre><code>nano galaxies.md\n</code></pre> Galaxy Constellation Type Andromeda Andromeda Spiral Milky Way (Center) Sagittarius Spiral Triangulum Triangulum Spiral Pisces Dwarf Pisces Irregular Leo A Leo Irregular"},{"location":"06_searching_for_files/","title":"Using <code>find</code> to Search Filenames","text":"<p>The <code>find</code> command recursively searches for files by name, type, size, or modification time. By default, the command prints the names of the files for which your entire expression is <code>true</code>, unless your expression contains an action besides <code>-prune</code> or <code>-quit</code>. </p> <p><code>find</code> searches your directory tree rooted from a given starting point, evaluating your entire expression from left to right until the outcome is determined as <code>True</code> or <code>False</code>, at which point <code>find</code> moves on to the next file (unless using the <code>-quit</code> argument). Without a specified search root, the current directory, <code>.</code>, is assumed. Also, if a starting point argument would normally begin with <code>-</code>, <code>find</code> would try to treat it instead as an expression. For this reason, it is generally safer to prefix wildcard or dubius path names with either <code>./</code>, or to use absolute path names starting with <code>/</code>.</p> <p>The expressions used to select files are comprised of one or more of the following four primaries.</p>"},{"location":"06_searching_for_files/#1-options-affects-overall-operation-rather-than-the-processing-of-a-specific-file","title":"1. <code>options</code>:   Affects overall operation rather than the processing of a specific file.","text":"<p>Most common <code>find</code> options:</p> <ul> <li><code>-maxdepth N</code><ul> <li>Limits how many subdirectories deep your expression will search starting from the search root.</li> </ul> </li> </ul> <pre><code>find . -maxdepth 1 -name \"*.log\" # Looks for .log files in the current directory\n</code></pre> <ul> <li><code>-mindepth N</code><ul> <li>Skips a number of directory levels before applying tests.</li> </ul> </li> </ul> <pre><code>find . -mindepth 2 -type f # Skips top and first subdirectory to find files\n</code></pre> <ul> <li><code>-depth</code><ul> <li>Processes directory contents before directory itself. </li> </ul> </li> </ul> <pre><code>find . -depth -name \".txt\" -delete # Removes .txt files from directory before directory is handled\n</code></pre> <ul> <li><code>-xdev</code>/<code>-mount</code><ul> <li>Prevents <code>find</code> from crossing into other mounted filesystems such as partitions or mounted drives.</li> </ul> </li> </ul> <pre><code>find / -xdev -name \"*.conf\" # Searches only root, skipping /mnt, /boot, and similar if mounted separately\n</code></pre>"},{"location":"06_searching_for_files/#2-tests-returns-a-true-or-false-value-depending-on-the-files-attributes","title":"2. <code>tests</code>:     Returns a true or false value depending on the file's attributes.","text":"<p><code>N</code> can be <code>+N</code>, <code>-N</code>, or just <code>N</code></p> <p>Most common <code>find</code> tests: * <code>-name PATTERN</code>/<code>-iname PATTERN</code>    * Matches files by name. <code>-iname</code> is case-insensitive.    * Wildcards like <code>*</code> and <code>?</code> are supported.</p> <pre><code>find . -name \"*.txt\"   # Find all .txt files\nfind . -iname \"readme\" # Find all case-insensitive files that start with \"readme\"\n</code></pre> <ul> <li><code>-type</code><ul> <li>Matches by file type:</li> <li><code>f</code>: Regular file</li> <li><code>d</code>: Directory</li> <li><code>l</code>: Symbolic link</li> </ul> </li> </ul> <pre><code>find . -type f        # Find regular files\nfind /testdir -type d # Find directories under /testdir\n</code></pre> <ul> <li><code>-mtime N</code>/<code>-mmin N</code><ul> <li>Matches files by modification time. .</li> <li><code>-mtime</code> uses days, <code>-mmin</code> uses minutes.</li> </ul> </li> </ul> <pre><code>find . -mtime -1 # Find files modified in the last day\nfind . -mmin +60 # Find files modified more than an hour ago\n</code></pre> <ul> <li><code>-size N[b|c|k|M|G]</code><ul> <li>Matches files by size.</li> <li><code>b</code>: 512-byte blocks, <code>c</code>: bytes, <code>k</code>: Kb, <code>M</code>: Mb, <code>G</code>: Gb</li> </ul> </li> </ul> <pre><code>find . -size +10M  # Find files larger than 10 Mb\nfind . -size -100K # Find files smaller than 100 Kb\nfind . -size 3b    # Find files that are exactly 3 blocks\n</code></pre> <ul> <li><code>-user NAME</code>/<code>-group NAME</code><ul> <li>Find files owned by a specific user or group.</li> </ul> </li> </ul> <pre><code>find /home -user admin # Find files owned by user named admin\nfind . -group www-data # Find files owned by www-data group\n</code></pre> <p><code>-nouser</code> and <code>-nogroup</code> can be used to find files with no associated user or group. Often used for deleted accounts.  * <code>-empty</code>     * Match empty files or directories</p> <pre><code>find . -type f -empty # Find empty files\nfind . -type d -empty # Find empty directories\n</code></pre> <ul> <li><code>-path</code>/<code>-wholename</code><ul> <li>Match full relative path (from search root)</li> </ul> </li> </ul> <pre><code>find . -path \"./src/*.txt\" # Find all .txt files in the src folder\n</code></pre> <ul> <li><code>-newer FILE</code>/<code>-anewer FILE</code>/<code>-cnewer FILE</code><ul> <li>Match files based on their modified/access/change times respectively</li> </ul> </li> </ul> <pre><code>find . -newer reference.txt # Find files which have been modified more recently than reference.txt\n</code></pre> <ul> <li><code>-readable</code>/<code>-writable</code>/<code>-executable</code><ul> <li>Checks the accessibilities for the current user.</li> </ul> </li> </ul> <pre><code>find . -type f -executable # Find executable files\n</code></pre>"},{"location":"06_searching_for_files/#3-actions-have-side-effects-and-returns-a-true-or-false-value","title":"3. <code>actions</code>:   Have side effects and returns a true or false value.","text":"<p>Most common <code>find</code> actions:</p> <ul> <li><code>-print</code><ul> <li>This is a default action which does not need to be specified. <code>-print</code> prints the patch of each file which matches the rest of the expression.</li> </ul> </li> <li><code>-fprint FILE</code><ul> <li>This prints the entire file name into a file, <code>FILE</code>, followed by a newline. This will also create the <code>FILE</code> if it does not already exist.</li> </ul> </li> </ul> <pre><code>find . -name \".txt\" -fprint \"save_txt.txt\" # Saves the path for every .txt file to save_txt.txt \n</code></pre> <ul> <li><code>-delete</code><ul> <li>Deletes each file which matches the expression: Use with caution. This command is often combined with <code>-type</code> to avoid deleting directories or special files by accident.</li> </ul> </li> </ul> <pre><code>find . name \"*.tmp\" -type f -delete # Deletes all .tmp files\n</code></pre> <ul> <li><code>-exec COMMAND {} \\;</code><ul> <li>Runs a command for each matching file. The shell substitutes <code>{}</code> with the full path to the file when running. <code>\\;</code> then terminates the command.</li> <li>You can also replace <code>\\;</code> with <code>+</code> to have the command run once with multiple file arguments instead of once per file.</li> </ul> </li> </ul> <pre><code>find . -name \"*.txt\" -exec gzip {} \\; # Compresses each .txt file\nfind . -name \"*.log\" -exec rm {} +    # Deletes all .log files in batches\n</code></pre> <ul> <li><code>-prune</code><ul> <li>Stops <code>find</code> from descending into matching directories. This action is common for skipping paths.</li> </ul> </li> </ul> <pre><code>find . -path \"./.git\" -prune -o -name \"*.py\" -print # Skips .git, listing Python files elsewhere.\n</code></pre> <ul> <li><code>-quit</code><ul> <li>Stops after the first match. Useful for fast existence checks.</li> </ul> </li> </ul> <p>Some less common <code>actions</code> that are still useful in scripts include:</p> <ul> <li><code>-print0</code> and <code>-fprint0 FILE</code><ul> <li>Prints filenames with a null character instead of a newline. This action is ideal for filenames which include spaces.</li> </ul> </li> <li><code>-ls</code><ul> <li>Prints <code>ls -dils</code> style info for each file.</li> </ul> </li> <li><code>-ok COMMAND ;</code><ul> <li>Like <code>-exec</code>, but prompts for confirmation before running each command.</li> </ul> </li> <li><code>-execdir</code>, <code>-okdir</code><ul> <li>Like <code>-exec</code>, but runs the command in the directory of the matching file instead of where <code>find</code> was run. Useful when the command depends on relative paths.</li> </ul> </li> </ul>"},{"location":"06_searching_for_files/#4-operators-connects-the-other-arguments-and-affect-when-and-whether-they-are-evaluated","title":"4. <code>operators</code>: Connects the other arguments and affect when and whether they are evaluated.","text":"<p><code>find</code> allows for you to combine multiple tests using logical operators such as AND, OR, and NOT, along with grouping using parentheses. These operators can be very powerful for creating more precise search expressions: * <code>-and</code>/<code>-a</code> (or a space)     * All expressions must be true. This is the defualt behavior of <code>find</code>: listing conditions will automatically use \"and\", but it can be writen explicitely with <code>-and</code>.</p> <pre><code>find . -type f -name \"*.sh\"\n# Equivalent to:\nfind . -type f -and -name \"*.sh\"\n# Equivalent to:\nfind . -type f -a -name \"*.sh\"\n# All three will find .sh files\n</code></pre> <ul> <li><code>-or</code>/<code>-o</code><ul> <li>Matches if either condition is true.</li> </ul> </li> </ul> <pre><code>find . -name \"*.jpg\" -or -name \"*.png\" # Prints .jpg and .png files\n</code></pre> <ul> <li><code>-not</code>/<code>!</code><ul> <li>Inverts a test</li> </ul> </li> </ul> <pre><code>find . -type f -not -name \"*.txt\"\n# or:\nfind . -type f ! -name \"*.txt\"\n# Prints all regular files that are not .txt\n</code></pre> <ul> <li><code>(</code> and <code>)</code><ul> <li>Allow for the grouping of expressions. Must be escaped or quoted in most shells in order to avoid shell interpretation: <code>\\(...\\)</code></li> </ul> </li> </ul> <pre><code>find . \\( -name \"*.jpg\" -or -name \"*.png\" \\) -not -path \"./backup/*\" # Finds .jpg and .png files, exlcuding anything in ./backup\n</code></pre>"},{"location":"06_searching_for_files/#operation-order","title":"Operation Order","text":"<p><code>find</code> lists the precedence order for operators from highest to lowest as:</p> <ol> <li> <p><code>()</code></p> </li> <li> <p><code>!</code>/<code>-not</code></p> </li> <li> <p>Then <code>-and</code></p> </li> <li> <p>Then <code>-or</code></p> </li> </ol> <p>Now that we have a better handle on searching for specific files, click here to continue on to the next section to learn how to search for specific text inside of your files.</p>"},{"location":"07_searching_inside_files/","title":"Using <code>grep</code> to Search Inside Files","text":"<p>The <code>grep</code> command (a contraction of \"global/regular expression/print\") allows for searching through text files with commands to perform simple or recursive searches, while also allowing for multiple search terms, the ability to count matches, and even allowing users to pipe the output to other commands for further manipulation.</p> <p>The basic syntax of <code>grep</code> follows:</p> <pre><code>grep [OPTIONS] PATTERNS [FILES]\n</code></pre> <p><code>grep</code> will then search for the given <code>PATTERN</code> in each of the listed files, and then by default will simply print the related line. The available options for <code>grep</code> are separated into 4 different groups:</p>"},{"location":"07_searching_inside_files/#1-pattern-selection-and-interpretation","title":"1: Pattern Selection and Interpretation","text":"<p>These options define how <code>grep</code> understands and applies your search pattern, allowing you to switch between simple string matching and the more powerful regular expressions, as well as allowing you to control case sensitivity and match boundaries. The most common options you'll use here are:</p> <ul> <li> <p><code>-E</code>/<code>--extended-regexp</code></p> <ul> <li>Allows your <code>PATTERN</code> to be interpreted as an extended regular expression, allowing for more complex syntax like <code>+</code>, <code>?</code>, and <code>|</code> without needing backslashes.</li> </ul> </li> <li> <p><code>-F</code>/<code>--fixed-strings</code></p> <ul> <li>Treats your pattern as a literal string instead of a regular expression. This is faster for simple, exact matches.</li> </ul> </li> <li> <p><code>-G</code>/<code>--basic-regexp</code></p> <ul> <li>Uses basic regular expressions, and is the default mode of <code>grep</code> unless overridden by another options. Special characters require escaping with this option.</li> </ul> </li> <li> <p><code>-P</code>/<code>--perl-regexp</code></p> <ul> <li>Enables Perl-compatible regular expressions, allowing for even more advanced and expressive syntax.</li> </ul> </li> <li> <p><code>-e PATTERN</code>/<code>--regexp=PATTERN</code></p> <ul> <li>Specifies the pattern directly; useful when mixing multiple patterns or reading from a script.</li> </ul> </li> <li> <p><code>-f FILE</code>/<code>--file=FILE</code></p> <ul> <li>Loads the search patterns from a file, one pattern per line, comparing each line against another file. This is helpful for long lists of search terms.</li> </ul> </li> </ul> <pre><code>grep -f patterns.txt data.txt\n</code></pre> <ul> <li> <p><code>-i</code>/<code>--ignore-case</code></p> <ul> <li>Performs a case-insensitive search</li> </ul> </li> <li> <p><code>--no-ignore-case</code></p> <ul> <li>Explicitly disable case-insensitive matching. This can be useful in scripts where flags may vary.</li> </ul> </li> <li> <p><code>-w</code>/<code>--word-regexp</code></p> <ul> <li>Match whole words only, ignoring partial matches.</li> </ul> </li> </ul> <pre><code>grep -w 'cat' file.txt # Matches \"cat\", not \"concatenate\"\n</code></pre> <ul> <li> <p><code>-x</code>/<code>--line-regexp</code></p> <ul> <li>Matches entire lines exactly.</li> </ul> </li> <li> <p><code>-z</code>/<code>--null-data</code></p> <ul> <li>Treat input as null-delimited. This option is useful for special binary or structured formats. Each \"line\" ends in a null byte (<code>\\0</code>) instead of a newline.</li> </ul> </li> </ul>"},{"location":"07_searching_inside_files/#2-miscellaneous","title":"2: Miscellaneous","text":"<p>These options don't directly affect how <code>grep</code> interprets or searches for patterns but help with controlling its behaviour, output, or interaction with the shell.</p> <ul> <li> <p><code>-s</code>/<code>--no-messages</code></p> <ul> <li>Suppresses error messages about unreadable files.</li> </ul> </li> <li> <p><code>-v</code>/<code>--invert-match</code></p> <ul> <li>Selects lines that do not match the given pattern. Often used to exclude known entries or to filter out unwanted matches. </li> </ul> </li> </ul>"},{"location":"07_searching_inside_files/#3-output-control","title":"3: Output Control","text":"<p>These options customize how <code>grep</code> displays its results. They are able to help you manage large outputs, script more effectively, and integrate with tools that expect specific formats.</p>"},{"location":"07_searching_inside_files/#basic-display-controls","title":"Basic Display Controls:","text":"<ul> <li><code>-m NUM</code>/<code>--max-count=NUM</code><ul> <li>Stop reading a file after finding the first <code>NUM</code> matching lines.</li> </ul> </li> </ul> <pre><code>grep -m 3 'error' -i log.txt # Case-insensitive; prints out first 3 error messages from log.txt.\n</code></pre> <ul> <li> <p><code>-b</code>/<code>--byte-offset</code></p> <ul> <li>Prints the byte offset (position) of each matching line's start within the file.</li> </ul> </li> <li> <p><code>-n</code>/<code>--line-number</code></p> <ul> <li>Show the line number for each match. This is especially helpful when working with large files.</li> </ul> </li> <li> <p><code>--line-buffered</code></p> <ul> <li>Flushes output after every line instead of buffering. Useful for piping <code>grep</code> into tools that need live output.</li> </ul> </li> </ul>"},{"location":"07_searching_inside_files/#file-identification-options","title":"File Identification Options:","text":"<ul> <li> <p><code>-H</code>/<code>--with-filename</code></p> <ul> <li>Always show the file name in the output. This is a default option when multiple files are searched.</li> </ul> </li> <li> <p><code>-h</code>/<code>--no-filename</code></p> <ul> <li>Suppress the file name output, such as when searching for multiple files if you only care about the content, not which file the content is from.</li> </ul> </li> </ul>"},{"location":"07_searching_inside_files/#match-content-refinement","title":"Match Content Refinement:","text":"<ul> <li> <p><code>-o</code>/<code>--only-matching</code></p> <ul> <li>Prints only the part of each line that matches the search pattern.</li> </ul> </li> <li> <p><code>-q</code>/<code>--quiet</code>/<code>--silent</code></p> <ul> <li>Suppresses all normal outputs. This is useful for testing the presence or absence of a pattern in scripts.</li> </ul> </li> </ul> <pre><code>grep -q 'admin' users.txt &amp;&amp; echo \"User found.\" # Returns only the echo message if admin found in users.txt\n</code></pre>"},{"location":"07_searching_inside_files/#binary-and-encoding-options","title":"Binary and Encoding Options:","text":"<ul> <li> <p><code>--binary-files=TYPE</code></p> <ul> <li>Choose how to handle binary files.<ul> <li><code>binary</code>: Treat as binary (default).</li> <li><code>text</code>: Treat as if plain text.</li> <li><code>without-match</code>: Silently skip binary files.</li> </ul> </li> </ul> </li> <li> <p><code>a</code>/<code>--text</code> are equivalent to <code>--binary-files=text</code></p> </li> <li> <p><code>-I</code> is equivalent to <code>--binary-files=without-match</code></p> </li> </ul>"},{"location":"07_searching_inside_files/#directory-and-recursion","title":"Directory and Recursion:","text":"<ul> <li> <p><code>-d ACTION</code>/<code>--directories=ACTION</code></p> <ul> <li>Allows you to choose what to do with directories.<ul> <li><code>read</code>: Read them as files.</li> <li><code>recurse</code>: Search inside of them recursively.</li> <li><code>skip</code>: Ignore them (this is the default unless <code>-r</code> is used).</li> </ul> </li> </ul> </li> <li> <p><code>-D ACTION</code>/<code>--devices=ACTION</code></p> <ul> <li>Similar to <code>-d</code>, but for device files, FIFOs, or sockets.</li> </ul> </li> <li> <p><code>-r</code>/<code>--recursive</code></p> <ul> <li>Recursively searches subdirectories (does not follow symlinks).</li> </ul> </li> <li> <p><code>-R</code>/<code>--dereference-recursive</code></p> <ul> <li>Like <code>-r</code>, but does follow symlinks.</li> </ul> </li> </ul>"},{"location":"07_searching_inside_files/#file-filtering","title":"File Filtering:","text":"<ul> <li> <p><code>--include=GLOB</code></p> <ul> <li>Restrict search to files matching a glob pattern.</li> </ul> </li> <li> <p><code>--exclude=GLOB</code></p> <ul> <li>Skips files that match the pattern.</li> </ul> </li> <li> <p><code>--exclude-from=FILE</code></p> <ul> <li>Read exclusion patterns (one per line) from a given file.</li> </ul> </li> <li> <p><code>--exclude-dir=GLOB</code></p> <ul> <li>Skip directories that match the pattern.</li> </ul> </li> </ul>"},{"location":"07_searching_inside_files/#summary-output","title":"Summary Output:","text":"<ul> <li> <p><code>-L</code>/<code>--files-without-match</code> </p> <ul> <li>Prints the names of files that contain no matches.</li> </ul> </li> <li> <p><code>-l</code>/<code>--files-with-matches</code> </p> <ul> <li>Prints the names of files with at least one match.</li> </ul> </li> <li> <p><code>-c</code>/<code>--count</code></p> <ul> <li>Prints a count of the number of matches per file instead of the actual matches.</li> </ul> </li> </ul>"},{"location":"07_searching_inside_files/#formatting","title":"Formatting:","text":"<ul> <li> <p><code>-T</code>/<code>--initial-tab</code></p> <ul> <li>Align fields properly if tab characters are present in the output.</li> </ul> </li> <li> <p><code>-Z</code>/<code>--null</code></p> <ul> <li>Output a null character (<code>\\0</code>) after file names. This can be useful when filenames contain spaces or newlines.</li> </ul> </li> </ul>"},{"location":"07_searching_inside_files/#4-context-control","title":"4: Context Control","text":"<p>When searching for a pattern in a file, sometimes the goal is to see not just the matching line, but also the surrounding context. <code>grep</code> provides a set of options to include lines before or after matches, which can be especially helpful in logs, source code, or debugging outputs.</p>"},{"location":"07_searching_inside_files/#showing-context-around-matches","title":"Showing Context Around Matches:","text":"<ul> <li> <p><code>-B NUM</code>/<code>--before-context=NUM</code></p> <ul> <li>Show <code>NUM</code> lines before each match.</li> </ul> </li> <li> <p><code>-A NUM</code>/<code>--after-context=NUM</code></p> <ul> <li>Show <code>NUM</code> lines after each match.</li> </ul> </li> <li> <p><code>-C NUM</code>/<code>--context=NUM</code>/<code>-NUM</code></p> <ul> <li>Show <code>NUM</code> lines before and after each match.</li> </ul> </li> </ul> <pre><code>grep -3 'error' diagnostics.txt\n</code></pre>"},{"location":"07_searching_inside_files/#formatting-context-blocks","title":"Formatting Context Blocks:","text":"<ul> <li> <p><code>--group-separator=SEP</code></p> <ul> <li>Insert <code>SEP</code> between blocks of matches when context is shown. Default is <code>--</code>.</li> </ul> </li> <li> <p><code>--no-group-separator</code></p> <ul> <li>Suppresses the line between context-separated match blocks entirely.</li> </ul> </li> </ul> <p>These options are useful when post-processing <code>grep</code> output and want consistent formatting or no interruptions between context groups.</p>"},{"location":"07_searching_inside_files/#highlighting-matches","title":"Highlighting Matches:","text":"<ul> <li><code>--color[=WHEN]</code>/<code>--colour[=WHEN]</code><ul> <li>Highlight matching text using ANSI escape sequences. <code>WHEN</code> can be:<ul> <li><code>always</code>: Force color, even when not writing to a terminal.</li> <li><code>never</code>: Disable color.</li> <li><code>auto</code>: Color only if output goes to a terminal.</li> </ul> </li> </ul> </li> </ul> <p>Most modern terminal setups default to <code>--color=auto</code>.</p>"},{"location":"07_searching_inside_files/#line-ending-handling","title":"Line Ending Handling:","text":"<ul> <li><code>-U</code>/<code>--binary</code><ul> <li>Disable stripping of <code>\\r</code> (carriage return) characters at the end of lines. This is useful when dealing with files from Windows systems (CRLF line endings). This option helps preserve exact formatting in mixed-platform environments.</li> </ul> </li> </ul>"},{"location":"examples/constellations/","title":"Constellations","text":"Constellation Brightest Star Aries Hamal Taurus Aldebaran Gemini Pollux Cancer Al Tarf Leo Regulus Virgo Spica Libra Zubeneschamali Scorpius Antares Ophiuchus Rasalhague Sagittarius Kaus Australis Capricornus Deneb Algedi Aquarius Sadalsuud Pisces Alpherg"},{"location":"examples/galaxies/","title":"Galaxies","text":"Galaxy Constellation Type Andromeda Andromeda Spiral Milky Way (Center) Sagittarius Spiral Triangulum Triangulum Spiral Pisces Dwarf Pisces Irregular Leo A Leo Irregular"},{"location":"examples/planets/","title":"Planets","text":"Planet Radius (m) Distance (AU) Mass (Kg) Mercury 2.44E6 0.39 3.29E23 Venus 6.05E6 0.72 4.87E24 Earth 6.37E6 1 5.97E24 Mars 3.39E6 1.52 6.42E23 Jupiter 7.15E7 5.2 1.90E27 Saturn 6.03E7 9.54 5.69E26 Uranus 2.56E7 19.2 8.68E25 Neptune 2.48E7 30.1 1.02E26"}]}