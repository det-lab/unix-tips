{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md                    # The documentation homepage.\n    01_summary_and_setup.md     # Introduction\n    02_navigation.md            # Tips for navigating file system\n    03_command_history.md       # Tips for utilizing command history\n    04_file_operations.md       # Tips for organizing files\n    05_searching_and_editing.md # Tips for searching for and editing files\n</code></pre>"},{"location":"01_summary_and_setup/","title":"Summary","text":"<p>The Unix shell is more than just a way to launch programs: it's a powerful environment for automating tasks, managing files, and interacting with your system efficiently. Whether you're using <code>bash</code>, <code>zsh</code>, or another variant, the shell can become a highly personalized and productive workspace once you know how to use it effectively. </p> <p>In this short series of lessons, we'll cover practical tips and time-saving techniques for working in the shell such as shortcuts for navigating directories, command history, file operations, search and substitution tricks, interpreting the UI colors, customization options, and more. </p>"},{"location":"01_summary_and_setup/#install-software","title":"Install Software","text":"<p>If you do not already have it installed, click this link for instructions on how to download and install the Bash shell for Windows, MacOS, or Linux. </p> <p>Click here to continue to the next section where we will go over tips for navigating directories with the Unix shell.</p>"},{"location":"02_navigation/","title":"Navigation","text":"<p>Before you can manage files and run scripts, it's necessary to understand and be comfortable with moving around your system from inside the shell. The Unix shell provides flexible commands for exploring the directory structure. This section will cover tips and common patterns for navigation that will save you time and help prevent mistakes.</p>"},{"location":"02_navigation/#basic-commands","title":"Basic Commands","text":"<ul> <li> <p><code>pwd</code>: Print Working Directory. This command gives a print out of the path to reach the directory you're currently working from. For instance, if you're opening Linux, <code>pwd</code> might return a path like: <code>/home/userName</code></p> </li> <li> <p><code>ls</code>: List. This command shows the contents of the current directory. </p> </li> <li> <p><code>cd &lt;directory&gt;</code>: Change Directory. This command allows you to move into a different folder.</p> </li> </ul> <p>You can also use <code>ls &lt;directory&gt;</code> or <code>ls &lt;path&gt;</code> to show the contents of a folder other than the one you're currently in. </p>"},{"location":"02_navigation/#useful-shortcuts","title":"Useful Shortcuts","text":"<ul> <li> <p><code>~</code> represents your home directory path, so <code>cd ~</code> will change your directory to the top of your folder tree and <code>ls ~</code> will show you same folder's contents.</p> </li> <li> <p><code>cd -</code> will return you to the previous directory you were in.</p> </li> <li> <p><code>.</code> refers to the current directory.</p> </li> <li> <p><code>..</code> refers to the parent directory, so <code>cd ..</code> will move you into the parent directory and <code>ls ..</code> will show the contents of the parent directory.</p> </li> </ul>"},{"location":"02_navigation/#tab-completion","title":"Tab Completion","text":"<p>You can start typing a directory or file name and press <code>Tab</code> to auto-complete. If multiple matches exist, pressing <code>Tab</code> twice will show you the options. This also works inside of different directories, meaning you can use <code>Tab</code> for each directory to shorten how much is needed to type to navigate deeper into a path. For instance:</p> <pre><code>cd Doc&lt;tab&gt;/Git&lt;tab&gt;/\n</code></pre> <p>would move you into the <code>Documents/Github</code> folder. </p> <p>Tab completion works slightly differently in different shells. <code>Powershell</code> and <code>Fish</code> are not case sensitive, while <code>Bash</code> and <code>Tcsh</code> are.</p>"},{"location":"02_navigation/#listing-files-more-effectively","title":"Listing Files More Effectively","text":"<p>There are several options that can be added after <code>ls</code> to modify its behavior. For a complete list, you can use <code>ls --help</code>. It's also important to note that it is possible to use different modifiers together for more comprehensive results. </p> <p>For instance, <code>-a</code> will show all files, including hidden ones such as dotfiles like <code>.gitignore</code>, while <code>-A</code> will show almost all files, ignoring <code>.</code> and <code>..</code> entries. <code>-l</code> will use a long listing format, <code>-h</code> will use a human readable format, <code>-r</code> will reverse the result order, and <code>-t</code> will sort by modified time. Stacking these options together allows for searches such as:</p> <pre><code>ls -lh # Long listing format with human-readable file sizes\nls -ltr # Long listing format, sort by modified time, oldest first\nls -Alh # Show almost all files, long listing format, human readable\n</code></pre>"},{"location":"02_navigation/#using-tree-for-a-visual-directory-structure","title":"Using <code>tree</code> for a Visual Directory Structure","text":"<p>The <code>tree</code> command visually maps directory structures, making it especially helpful when you need to understand the organization of nested directories, showing you directories without requiring you to manually navigate through each one. </p> <p>By default, <code>tree</code> is not installed, but it can be installed with the commands:</p> <pre><code>sudo yum install tree\n</code></pre> <p>or</p> <pre><code>sudo dnf install tree\n</code></pre> <p>For RHEL, CentOS, and Fedora Linux.</p> <pre><code>sudo apt-get install tree\n</code></pre> <p>For Debian, Mint, and Ubuntu Linux.</p> <pre><code>brew install tree\n</code></pre> <p>For Apple OS X.</p>"},{"location":"02_navigation/#basic-syntax-of-tree-command","title":"Basic Syntax of Tree Command","text":"<p>Just entering <code>tree</code> by itself will output your entire file structure starting from your current directory, making it not very useful without applying certain condtions. The basic command syntax is to use <code>tree [options]</code> for more precise usage. As before, you can enter <code>tree --help</code> in order to see a list of all options. </p> <p>A short list of options you might use more often include:</p> <ul> <li> <p><code>-a</code> or <code>--all</code>: Includes hidden files and directories in the tree.</p> </li> <li> <p><code>-d</code> or <code>--dirs-only</code>: List directories only.</p> </li> <li> <p><code>-f</code> or <code>--full-path</code>: Prints the full path prefix for each file.</p> </li> <li> <p><code>-p</code> or <code>--prune</code>: Omits specified directory from the tree.</p> </li> <li> <p><code>--filelimit #</code>: Doesn't descend directories that contain more than # entries.</p> </li> <li> <p><code>-s</code>: Prints the size of each file along with the name.</p> </li> <li> <p><code>-L #</code>: Sets a maximum depth, #, of the directory tree to display.</p> </li> </ul> <p>As before, these can also be mixed and matched. For instance, if you only wanted to visualize directories up to 3 folders deep and you also wanted to see the path for each file, you could run:</p> <pre><code>tree -dpL 3\n</code></pre> <p>Now that you're familiar with moving around and inspecting the filesystem, let's look at how you can save time using command history and quick recall tools. Click here to continue on to the next section.</p>"},{"location":"03_command_history/","title":"Command History and Quick Recall Tools","text":"<p>Typing the same long commands over and over can get tedious and error prone. Fortunately, Unix shells keep a command history that lets you easily recall, repeat, and modify previous commands. This section covers essential shortcuts and tools to speed up your workflow.</p>"},{"location":"03_command_history/#basic-history-navigation","title":"Basic History Navigation","text":"<ul> <li> <p>Press the up arrow to scroll through previous commands.</p> </li> <li> <p>Press the down arrow to move forward again.</p> </li> </ul> <p>You can also view a full numbered history of your previous commands with:</p> <pre><code>history\n</code></pre>"},{"location":"03_command_history/#search-through-command-history","title":"Search Through Command History","text":"<p>You can use reverse search to find previous commands be substring. From the shell, press <code>CTRL+R</code> to begin a reverse search. You can then start typing part of the command, and the shell will search backward through your history.</p> <ul> <li> <p>Keep pressing <code>CTRL+R</code> to cycle through more matches.</p> </li> <li> <p>Press <code>Enter</code> to run the found command.</p> </li> <li> <p>Press <code>Esc</code> or <code>CTRL+G</code> to cancel the search.</p> </li> </ul> <p>Tip: Use <code>CTRL+S</code> to search forward</p>"},{"location":"03_command_history/#repeat-previous-commands","title":"Repeat Previous Commands","text":"<ul> <li> <p><code>!!</code>: Repeat the last command.</p> </li> <li> <p><code>!n</code>: Run command number <code>n</code> from the output of <code>history</code>.</p> </li> <li> <p><code>!string</code>: Run the most recent command starting with a chosen <code>string</code>.</p> </li> <li> <p><code>!?string</code>: Run the most recent command containing a chosen <code>string</code>.</p> </li> </ul>"},{"location":"03_command_history/#examples","title":"Examples:","text":"<pre><code>!42      # Repeats command number 42\n!git     # Repeats the last command starting with \"git\"\n!?status # Repeats the last command that had \"status\" anywhere\n</code></pre>"},{"location":"03_command_history/#reuse-parts-of-previous-commands","title":"Reuse Parts of Previous Commands","text":"<ul> <li> <p><code>!$</code>: The last word of the previous command.</p> </li> <li> <p><code>!*</code>: All arguments from the previous command.</p> </li> <li> <p><code>^old^new</code>: Re-run the last command, replacing <code>old</code> with <code>new</code>.</p> </li> </ul>"},{"location":"03_command_history/#examples_1","title":"Examples:","text":"<pre><code>mkdir project\ncd !$\n</code></pre> <p>These commands would create and then move you into the \"project\" folder.</p> <pre><code>git commit -m \"fiz bug\"\n^fiz^fix\n</code></pre> <p>These commands would create the commit with the message \"fiz bug\" before creating another commit where \"fiz\" is replaced with \"fix\".</p> <pre><code>cp original.txt backup.txt\nvim !*\n</code></pre> <p>These commands would first copy <code>original.txt</code> to a file named <code>backup.txt</code> before then opening both files with the <code>vim</code> editor.</p>"},{"location":"03_command_history/#view-and-edit-commands-before-running","title":"View and Edit Commands Before Running","text":"<p>You can use <code>fc</code> (fix command) to open your previous command in your default editor, such as <code>nano</code>, <code>vim</code>, or <code>emacs</code>. This can be useful for making edits to long or complex commands before re-running them.</p> <p>Now that you can navigate and reuse your command history efficiently, we'll move on to file operations: copying, moving, renaming, and deleting files using the shell. Click here to continue on to the next section.</p>"},{"location":"04_file_operations/","title":"Working with Files: Copy, Move, and Remove","text":"<p>File operations are fundamental to using the Unix shell effectively. Whether you're managing project files, organizing backups, or scripting automation tasks, mastering a few essential commands can greatly streamline your workflow.</p>"},{"location":"04_file_operations/#creating-files-with-touch","title":"Creating files with <code>touch</code>","text":"<p>The <code>touch</code> command follows the basic format of:</p> <pre><code>touch [OPTION] FILE\n</code></pre> <p>The command updates the access and modification times of the selected file to the current time. It can also be used to create a new file if the <code>FILE</code> argument does not exist.</p>"},{"location":"04_file_operations/#useful-touch-options","title":"Useful <code>touch</code> Options","text":"<p>While there aren't options to influence the creation of a new file with <code>touch</code> (aside from not creating one using <code>-c</code> or <code>--no-create</code>), there are options to modify the access and modification times of an existing file, such as:</p> <ul> <li> <p><code>-a</code>: Change only the access time.</p> </li> <li> <p><code>-d [STRING]</code> or <code>--date=STRING</code>: Parse <code>STRING</code> and use it instead of the current time. </p> <p><code>STRING</code> must be in the format <code>[[CC]YY]MMDD</code>. If <code>YY</code> is specified but <code>CC</code> is not, a value for <code>YY</code> between 69 and 99 results in a <code>CC</code> value of 19. Otherwise, <code>CC</code> defaults to a value of 20. So, if you wanted to change the last modified date of a file to January 1st, 2018, you would use the command:</p> </li> </ul> <pre><code>touch -d 20180101 example.txt\n</code></pre> <ul> <li> <p><code>-h</code> or <code>--no-dereference</code>: This command affects symbolic links instead of referenced files.</p> </li> <li> <p><code>-m</code>: Changes the modification time to the current time.</p> </li> <li> <p><code>-t [STAMP]</code>: Parse a <code>STAMP</code> of the format <code>[[CC]YY]MMDDhhmm[.SS]</code> to be the new modification time.</p> <p>The same rules apply for the <code>[[CC]YY]MMDD</code> part of the argument. The <code>hh</code> argument uses a 24 hour clock (from 00 to 23). If you wished to change the modified date of a file to January 1st, 2018, at 5:28:30pm, you could use the command:</p> </li> </ul> <pre><code>touch -d 201801011728.30 example.txt\n</code></pre> <p>For more information on the basics of text editors which you can use to edit the contents of a file, you can follow this link to a short series of lessons on three of the most popular text editors, <code>nano</code>, <code>Vim</code>, and <code>Emacs</code>.</p>"},{"location":"04_file_operations/#making-folders-with-mkdir","title":"Making folders with <code>mkdir</code>","text":"<p>The <code>mkdir</code> command will create a new folder if one does not already exist. It follows the basic format of:</p> <pre><code>mkdir [OPTION] DIRECTORY\n</code></pre>"},{"location":"04_file_operations/#useful-mkdir-options","title":"Useful <code>mkdir</code> Options","text":"<ul> <li><code>-p</code> or <code>--parents</code>: Creates parent directories if necessary. For instance, running the following from a folder where <code>testdir</code> doesn't exist will create three total directories:</li> </ul> <pre><code>mkdir -p testdir/subdir/exampledir\n</code></pre> <ul> <li><code>-v</code>: Print a message for each created directory. This can be useful for automated scripts to show everything that gets created, potentially helping to find errors in directory creation.</li> </ul>"},{"location":"04_file_operations/#copying-files-with-cp","title":"Copying files with <code>cp</code>","text":"<p><code>cp</code> copies files or directories. The basic usage looks like:</p> <pre><code>cp [OPTION] SOURCE DEST\n</code></pre> <p>Where <code>SOURCE</code> and <code>DEST</code> would be the old and new filenames if you're copying the file to the same directory. For instance, if you're just copying a file to the same directory and changing its name, that would look like:</p> <pre><code>cp oldfile.txt backup.txt\n</code></pre> <p>You can also copy the original file into a new folder by setting <code>DEST</code> as the path, such as in:</p> <pre><code>mkdir testdir\ncp oldfile.txt testdir/\n</code></pre> <p>It is also possible to change the name of the copy in the same way:</p> <pre><code>cp oldfile.txt tesdir/backup.txt\n</code></pre>"},{"location":"04_file_operations/#useful-cp-options","title":"Useful <code>cp</code> Options","text":"<p>There are several common options to use with the copy command. These include:</p> <ul> <li> <p><code>-f</code> or <code>--force</code>: If an existing destination file cannot be opened, remove it and try again.</p> </li> <li> <p><code>-n</code> or <code>--no-clobber</code>: Prevents you from overwriting an existing file.</p> </li> <li> <p><code>-i</code> or <code>--interactive</code>: Prompts you for confirmation before overwriting an existing file.</p> </li> </ul> <p>Note that <code>-n</code> and <code>-i</code> will override each other. Only the second one will be used.</p> <ul> <li> <p><code>-R</code>, <code>-r</code>, or <code>--recursive</code>: Option required to copy a directory. </p> </li> <li> <p><code>-s</code> or <code>--symbolic-link</code>: Makes a symbolic link instead of copying the file. A symbolic link is similar to a shortcut, differing from copying in that changes to the original will effect the symbolic link version of the file as well, while copying creates an independant version of the file.</p> </li> </ul>"},{"location":"04_file_operations/#move-or-rename-files-with-mv","title":"Move or rename files with <code>mv</code>","text":"<p><code>mv</code> moves files if the target is a directory or renames them if the target includes a new name. This command differs from copying in that only one version of the file or directory is preserved. However the command is otherwise very similar, following the basic usage of:</p> <pre><code>mv [OPTION] SOURCE DEST\n</code></pre> <p>For instance, if you want to move a file to a new directory, you can use:</p> <pre><code>mv oldfile.txt testdir/\n</code></pre> <p>If you wish to rename it in the process:</p> <pre><code>mv oldfile.txt testdir/newname.txt\n</code></pre> <p>If you only wish to rename the file while keeping it in the same directory:</p> <pre><code>mv oldfile.txt newname.txt\n</code></pre>"},{"location":"04_file_operations/#useful-mv-options","title":"Useful <code>mv</code> Options","text":"<p>Some of the options are also the same as in the copy command, including:</p> <ul> <li> <p><code>-f</code>, <code>--force</code></p> </li> <li> <p><code>-i</code>, <code>--interactive</code>, and</p> </li> <li> <p><code>-n</code>, <code>--no-clobber</code></p> </li> </ul> <p>The other suggested options that are available in copy (<code>-R</code>, <code>-r</code>, <code>--recursive</code>, <code>-s</code>, and <code>--symbolic-link</code>) are not available for the <code>mv</code> command. </p>"},{"location":"04_file_operations/#delete-files-with-rm","title":"Delete files with <code>rm</code>","text":"<p><code>rm</code> deletes/unlinks files or folders, so use this option with caution. Its basic usage follows the format of:</p> <pre><code>rm [OPTION] FILE\n</code></pre> <p>Like with <code>cp</code> and <code>mv</code>, the <code>FILE</code> argument can be a path to a specific file outside of the directory that your shell is inside of.</p>"},{"location":"04_file_operations/#useful-rm-options","title":"Useful <code>rm</code> Options","text":"<ul> <li> <p><code>-f</code> or <code>--force</code>: Ignores nonexistent files and arguments.</p> </li> <li> <p><code>-i</code>: Prompts the user for confirmation before every removal.</p> </li> <li> <p><code>-I</code>: Prompts the user for confirmation if trying to remove more than three files, or when removing recursively. This is useful for automated scripts.</p> </li> <li> <p><code>-r</code>, -<code>R</code>, or <code>--recursive</code>: Remove directories and their contents.</p> </li> <li> <p><code>-d</code> or <code>--dir</code>: Removes empty directories.</p> </li> </ul>"},{"location":"04_file_operations/#destroy-files-with-shred","title":"Destroy files with <code>shred</code>","text":"<p><code>shred</code> is similar to <code>rm</code> in that it makes files unusable, but <code>shred</code> repeatedly overwrites the content, making it unrecoverable. Think of <code>rm</code> as like sending a file to your recycle bin, while <code>shred</code> is more like corrupting a file. It is still possible to recover files that have been removed with <code>rm</code> if you know what you're doing, but it is incredibly difficult to recover files that you <code>shred</code>, even using expensive hardware. Its basic usage follows the format of:</p> <pre><code>shred [OPTION] FILE\n</code></pre> <p>When you <code>shred</code> a file, there will still be a file with the given name and extension, but its contents will be unrecognizable. To demonstrate, try making an example file with a text editor:</p> <pre><code>nano example.txt\n</code></pre> <p>Then, write something to the file, save and quit (<code>CTRL+X</code> \\(\\to\\) <code>Y</code> \\(\\to\\) <code>Enter</code>), and <code>shred</code> the file.</p> <pre><code>shred example.txt\n</code></pre> <p>You can then run the command <code>nano example.txt</code> to open the file in your shell to see that your message has been transformed into a jumble of ASCII text.</p>"},{"location":"04_file_operations/#useful-shred-options","title":"Useful Shred Options","text":"<ul> <li> <p><code>-f</code> or <code>--force</code>: Changes permissions to allow writing to the file.</p> </li> <li> <p><code>-n</code> or <code>--iterations=N</code>: By default, <code>shred</code> will overwrite the file 3 times. This option allows you to specify how many times, N, to overwrite the file, making it potentially easier or more difficult to recover the data.</p> </li> <li> <p><code>-s</code> or <code>--size=N</code>: Allows you to specify a number, N, of bytes to overwrite.</p> </li> <li> <p><code>-u</code>: Remove file after overwriting it.</p> </li> <li> <p><code>-z</code> or <code>--zero</code>: Add a final overwrite with zeros to hide the shredding.</p> </li> </ul> <p>Now that you have a handle on creating, moving, and entering files and directories, click here to continue to the next section where we will discuss search and substitution tricks.</p>"},{"location":"05_searching_and_editing/","title":"Searching and Editing from the Shell","text":"<p>Here is where things start to get more complex. Unix provides several powerful tools for searching and manipulating files directly from the command line. Whether you're hunting down a misplaced file or editing configuration files in bulk, these commands are useful for saving a lot of time and effort.</p>"},{"location":"05_searching_and_editing/#searching-filenames","title":"Searching Filenames","text":""},{"location":"05_searching_and_editing/#find","title":"<code>find</code>","text":"<p>The <code>find</code> command recursively searches for files by name, type, size, or modification time. By default, the command prints the names of the files for which your entire expression is <code>true</code>, unless your expression contains an action besides <code>-prune</code> or <code>-quit</code>. </p> <p><code>find</code> searches your directory tree rooted from a given starting point, evaluating your entire expression from left to right until the outcome is determined as <code>True</code> or <code>False</code>, at which point <code>find</code> moves on to the next file (unless using the <code>-quit</code> argument). Without a specified search root, the current directory <code>.</code> is assumed. Also, if a starting point argument would normally begin with <code>-</code>, <code>find</code> would try to treat it instead as an expression. For this reason, it is generally safer to prefix wildcard or dubius path names with either <code>./</code>, or to use absolute path names starting with <code>/</code>.</p> <p>The expressions used to select files are comprised of one or more of the following four primaries.</p>"},{"location":"05_searching_and_editing/#1-options-affects-overall-operation-rather-than-the-processing-of-a-specific-file","title":"1. <code>options</code>:   Affects overall operation rather than the processing of a specific file.","text":"<p>Most common <code>find</code> options:</p> <ul> <li><code>-maxdepth N</code><ul> <li>Limits how many subdirectories deep your expression will search starting from the search root.</li> </ul> </li> </ul> <pre><code>find . -maxdepth 1 -name \"*.log\" # Looks for .log files in the current directory\n</code></pre> <ul> <li><code>-mindepth N</code><ul> <li>Skips a number of directory levels before applying tests.</li> </ul> </li> </ul> <pre><code>find . -mindepth 2 -type f # Skips top and first subdirectory to find files\n</code></pre> <ul> <li><code>-depth</code><ul> <li>Processes directory contents before directory itself. </li> </ul> </li> </ul> <pre><code>find . -depth -name \".txt\" -delete # Removes .txt files from directory before directory is handled\n</code></pre> <ul> <li><code>-xdev</code>/<code>-mount</code><ul> <li>Prevents <code>find</code> from crossing into other mounted filesystems such as partitions or mounted drives.</li> </ul> </li> </ul> <pre><code>find / -xdev -name \"*.conf\" # Searches only root, skipping /mnt, /boot, and similar if mounted separately\n</code></pre>"},{"location":"05_searching_and_editing/#2-tests-returns-a-true-or-false-value-depending-on-the-files-attributes","title":"2. <code>tests</code>:     Returns a true or false value depending on the file's attributes.","text":"<p><code>N</code> can be <code>+N</code>, <code>-N</code>, or just <code>N</code></p> <p>Most common <code>find</code> tests: * <code>-name PATTERN</code>/<code>-iname PATTERN</code>    * Matches files by name. <code>-iname</code> is case-insensitive.    * Wildcards like <code>*</code> and <code>?</code> are supported.</p> <pre><code>find . -name \"*.txt\"   # Find all .txt files\nfind . -iname \"readme\" # Find all case-insensitive files that start with \"readme\"\n</code></pre> <ul> <li><code>-type</code><ul> <li>Matches by file type:</li> <li><code>f</code>: Regular file</li> <li><code>d</code>: Directory</li> <li><code>l</code>: Symbolic link</li> </ul> </li> </ul> <pre><code>find . -type f        # Find regular files\nfind /testdir -type d # Find directories under /testdir\n</code></pre> <ul> <li><code>-mtime N</code>/<code>-mmin N</code><ul> <li>Matches files by modification time. .</li> <li><code>-mtime</code> uses days, <code>-mmin</code> uses minutes.</li> </ul> </li> </ul> <pre><code>find . -mtime -1 # Find files modified in the last day\nfind . -mmin +60 # Find files modified more than an hour ago\n</code></pre> <ul> <li><code>-size N[b|c|k|M|G]</code><ul> <li>Matches files by size.</li> <li><code>b</code>: 512-byte blocks, <code>c</code>: bytes, <code>k</code>: Kb, <code>M</code>: Mb, <code>G</code>: Gb</li> </ul> </li> </ul> <pre><code>find . -size +10M  # Find files larger than 10 Mb\nfind . -size -100K # Find files smaller than 100 Kb\nfind . -size 3b    # Find files that are exactly 3 blocks\n</code></pre> <ul> <li><code>-user NAME</code>/<code>-group NAME</code><ul> <li>Find files owned by a specific user or group.</li> </ul> </li> </ul> <pre><code>find /home -user admin # Find files owned by user named admin\nfind . -group www-data # Find files owned by www-data group\n</code></pre> <p><code>-nouser</code> and <code>-nogroup</code> can be used to find files with no associated user or group. Often used for deleted accounts.  * <code>-empty</code>     * Match empty files or directories</p> <pre><code>find . -type f -empty # Find empty files\nfind . -type d -empty # Find empty directories\n</code></pre> <ul> <li><code>-path</code>/<code>-wholename</code><ul> <li>Match full relative path (from search root)</li> </ul> </li> </ul> <pre><code>find . -path \"./src/*.txt\" # Find all .txt files in the src folder\n</code></pre> <ul> <li><code>-newer FILE</code>/<code>-anewer FILE</code>/<code>-cnewer FILE</code><ul> <li>Match files based on their modified/access/change times respectively</li> </ul> </li> </ul> <pre><code>find . -newer reference.txt # Find files which have been modified more recently than reference.txt\n</code></pre> <ul> <li><code>-readable</code>/<code>-writable</code>/<code>-executable</code><ul> <li>Checks the accessibilities for the current user.</li> </ul> </li> </ul> <pre><code>find . -type f -executable # Find executable files\n</code></pre>"},{"location":"05_searching_and_editing/#3-actions-have-side-effects-and-returns-a-true-or-false-value","title":"3. <code>actions</code>:   Have side effects and returns a true or false value.","text":"<p>Most common <code>find</code> actions:</p> <ul> <li><code>-print</code><ul> <li>This is a default action which does not need to be specified. <code>-print</code> prints the patch of each file which matches the rest of the expression.</li> </ul> </li> <li><code>-fprint FILE</code><ul> <li>This prints the entire file name into a file, <code>FILE</code>, followed by a newline. This will also create the <code>FILE</code> if it does not already exist.</li> </ul> </li> </ul> <pre><code>find . -name \".txt\" -fprint \"save_txt.txt\" # Saves the path for every .txt file to save_txt.txt \n</code></pre> <ul> <li><code>-delete</code><ul> <li>Deletes each file which matches the expression: Use with caution. This command is often combined with <code>-type</code> to avoid deleting directories or special files by accident.</li> </ul> </li> </ul> <pre><code>find . name \"*.tmp\" -type f -delete # Deletes all .tmp files\n</code></pre> <ul> <li><code>-exec COMMAND {} \\;</code><ul> <li>Runs a command for each matching file. The shell substitutes <code>{}</code> with the full path to the file when running. <code>\\;</code> then terminates the command.</li> <li>You can also replace <code>\\;</code> with <code>+</code> to have the command run once with multiple file arguments instead of once per file.</li> </ul> </li> </ul> <pre><code>find . -name \"*.txt\" -exec gzip {} \\; # Compresses each .txt file\nfind . -name \"*.log\" -exec rm {} +    # Deletes all .log files in batches\n</code></pre> <ul> <li><code>-prune</code><ul> <li>Stops <code>find</code> from descending into matching directories. This action is common for skipping paths.</li> </ul> </li> </ul> <pre><code>find . -path \"./.git\" -prune -o -name \"*.py\" -print # Skips .git, listing Python files elsewhere.\n</code></pre> <ul> <li><code>-quit</code><ul> <li>Stops after the first match. Useful for fast existence checks.</li> </ul> </li> </ul> <p>Some less common <code>actions</code> that are still useful in scripts include:</p> <ul> <li><code>-print0</code> and <code>-fprint0 FILE</code><ul> <li>Prints filenames with a null character instead of a newline. This action is ideal for filenames which include spaces.</li> </ul> </li> <li><code>-ls</code><ul> <li>Prints <code>ls -dils</code> style info for each file.</li> </ul> </li> <li><code>-ok COMMAND ;</code><ul> <li>Like <code>-exec</code>, but prompts for confirmation before running each command.</li> </ul> </li> <li><code>-execdir</code>, <code>-okdir</code><ul> <li>Like <code>-exec</code>, but runs the command in the directory of the matching file instead of where <code>find</code> was run. Useful when the command depends on relative paths.</li> </ul> </li> </ul>"},{"location":"05_searching_and_editing/#4-operators-connects-the-other-arguments-and-affect-when-and-whether-they-are-evaluated","title":"4. <code>operators</code>: Connects the other arguments and affect when and whether they are evaluated.","text":"<p><code>find</code> allows for you to combine multiple tests using logical operators such as AND, OR, and NOT, along with grouping using parentheses. These operators can be very powerful for creating more precise search expressions: * <code>-and</code>/<code>-a</code> (or a space)     * All expressions must be true. This is the defualt behavior of <code>find</code>: listing conditions will automatically use \"and\", but it can be writen explicitely with <code>-and</code>.</p> <pre><code>find . -type f -name \"*.sh\"\n# Equivalent to:\nfind . -type f -and -name \"*.sh\"\n# Equivalent to:\nfind . -type f -a -name \"*.sh\"\n# All three will find .sh files\n</code></pre> <ul> <li><code>-or</code>/<code>-o</code><ul> <li>Matches if either condition is true.</li> </ul> </li> </ul> <pre><code>find . -name \"*.jpg\" -or -name \"*.png\" # Prints .jpg and .png files\n</code></pre> <ul> <li><code>-not</code>/<code>!</code><ul> <li>Inverts a test</li> </ul> </li> </ul> <pre><code>find . -type f -not -name \"*.txt\"\n# or:\nfind . -type f ! -name \"*.txt\"\n# Prints all regular files that are not .txt\n</code></pre>"}]}