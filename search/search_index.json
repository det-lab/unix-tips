{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#project-layout","title":"Project layout","text":"<p>Created by Adrian Fisher</p> <pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md                     # The documentation homepage.\n    01_summary_and_setup.md      # Introduction\n    02_navigation.md             # Tips for navigating file system\n    03_command_history.md        # Tips for utilizing command history\n    04_file_operations.md        # Tips for organizing files\n    05_creating_example_files.md # Creating files for examples\n    06_searching_for_files.md    # Tips on how to search for files\n    07_searching_inside_files.md # Tips on searching for content inside files\n    08_editing_files.md          # Explaining ways to edit the content inside files\n    09_shell_scripts.md          # Learning how to script with the shell\n    examples/\n        constellations.csv \n        galaxies.csv\n        planets.csv\n</code></pre>"},{"location":"01_summary_and_setup/","title":"Summary","text":"<p>The Unix shell is more than just a way to launch programs: it's a powerful environment for automating tasks, managing files, and interacting with your system efficiently. Whether you're using <code>bash</code>, <code>zsh</code>, or another variant, the shell can become a highly personalized and productive workspace once you know how to use it effectively. </p> <p>In this short series of lessons, we'll cover practical tips and time-saving techniques for working in the shell such as shortcuts for navigating directories, command history, file operations, search and substitution tricks, interpreting the UI colors, customization options, and more. </p>"},{"location":"01_summary_and_setup/#install-software","title":"Install Software","text":"<p>If you do not already have it installed, click this link for instructions on how to download and install the Bash shell for Windows, MacOS, or Linux. </p> <p>Click here to continue to the next section where we will go over tips for navigating directories with the Unix shell.</p>"},{"location":"02_navigation/","title":"Navigation","text":"<p>Before you can manage files and run scripts, it's necessary to understand and be comfortable with moving around your system from inside the shell. The Unix shell provides flexible commands for exploring the directory structure. This section will cover tips and common patterns for navigation that will save you time and help prevent mistakes.</p>"},{"location":"02_navigation/#basic-commands","title":"Basic Commands","text":"<ul> <li> <p><code>pwd</code>: Print Working Directory. This command gives a print out of the path to reach the directory you're currently working from. For instance, if you're opening Linux, <code>pwd</code> might return a path like: <code>/home/userName</code></p> </li> <li> <p><code>ls</code>: List. This command shows the contents of the current directory. </p> </li> <li> <p><code>cd &lt;directory&gt;</code>: Change Directory. This command allows you to move into a different folder.</p> </li> </ul> <p>You can also use <code>ls &lt;directory&gt;</code> or <code>ls &lt;path&gt;</code> to show the contents of a folder other than the one you're currently in. </p>"},{"location":"02_navigation/#useful-shortcuts","title":"Useful Shortcuts","text":"<ul> <li> <p><code>~</code> represents your home directory path, so <code>cd ~</code> will change your directory to the top of your folder tree and <code>ls ~</code> will show you same folder's contents.</p> </li> <li> <p><code>cd -</code> will return you to the previous directory you were in.</p> </li> <li> <p><code>.</code> refers to the current directory.</p> </li> <li> <p><code>..</code> refers to the parent directory, so <code>cd ..</code> will move you into the parent directory and <code>ls ..</code> will show the contents of the parent directory.</p> </li> </ul>"},{"location":"02_navigation/#tab-completion","title":"Tab Completion","text":"<p>You can start typing a directory or file name and press <code>Tab</code> to auto-complete. If multiple matches exist, pressing <code>Tab</code> twice will show you the options. This also works inside of different directories, meaning you can use <code>Tab</code> for each directory to shorten how much is needed to type to navigate deeper into a path. For instance:</p> <pre><code>cd Doc&lt;tab&gt;/Git&lt;tab&gt;/\n</code></pre> <p>would move you into the <code>Documents/Github</code> folder. </p> <p>Tab completion works slightly differently in different shells. <code>Powershell</code> and <code>Fish</code> are not case sensitive, while <code>Bash</code> and <code>Tcsh</code> are.</p>"},{"location":"02_navigation/#listing-files-more-effectively","title":"Listing Files More Effectively","text":"<p>There are several options that can be added after <code>ls</code> to modify its behavior. For a complete list, you can use <code>ls --help</code>. It's also important to note that it is possible to use different modifiers together for more comprehensive results. </p> <p>For instance, <code>-a</code> will show all files, including hidden ones such as dotfiles like <code>.gitignore</code>, while <code>-A</code> will show almost all files, ignoring <code>.</code> and <code>..</code> entries. <code>-l</code> will use a long listing format, <code>-h</code> will use a human readable format, <code>-r</code> will reverse the result order, and <code>-t</code> will sort by modified time. Stacking these options together allows for searches such as:</p> <pre><code>ls -lh # Long listing format with human-readable file sizes\nls -ltr # Long listing format, sort by modified time, oldest first\nls -Alh # Show almost all files, long listing format, human readable\n</code></pre>"},{"location":"02_navigation/#using-tree-for-a-visual-directory-structure","title":"Using <code>tree</code> for a Visual Directory Structure","text":"<p>The <code>tree</code> command visually maps directory structures, making it especially helpful when you need to understand the organization of nested directories, showing you directories without requiring you to manually navigate through each one. </p> <p>By default, <code>tree</code> is not installed, but it can be installed with the commands:</p> <pre><code>sudo yum install tree\n</code></pre> <p>or</p> <pre><code>sudo dnf install tree\n</code></pre> <p>For RHEL, CentOS, and Fedora Linux.</p> <pre><code>sudo apt-get install tree\n</code></pre> <p>For Debian, Mint, and Ubuntu Linux.</p> <pre><code>brew install tree\n</code></pre> <p>For Apple OS X.</p>"},{"location":"02_navigation/#basic-syntax-of-tree-command","title":"Basic Syntax of Tree Command","text":"<p>Just entering <code>tree</code> by itself will output your entire file structure starting from your current directory, making it not very useful without applying certain condtions. The basic command syntax is to use <code>tree [options]</code> for more precise usage. As before, you can enter <code>tree --help</code> in order to see a list of all options. </p> <p>A short list of options you might use more often include:</p> <ul> <li> <p><code>-a</code> or <code>--all</code>: Includes hidden files and directories in the tree.</p> </li> <li> <p><code>-d</code> or <code>--dirs-only</code>: List directories only.</p> </li> <li> <p><code>-f</code> or <code>--full-path</code>: Prints the full path prefix for each file.</p> </li> <li> <p><code>-p</code> or <code>--prune</code>: Omits specified directory from the tree.</p> </li> <li> <p><code>--filelimit #</code>: Doesn't descend directories that contain more than # entries.</p> </li> <li> <p><code>-s</code>: Prints the size of each file along with the name.</p> </li> <li> <p><code>-L #</code>: Sets a maximum depth, #, of the directory tree to display.</p> </li> </ul> <p>As before, these can also be mixed and matched. For instance, if you only wanted to visualize directories up to 3 folders deep and you also wanted to see the path for each file, you could run:</p> <pre><code>tree -dpL 3\n</code></pre> <p>Now that you're familiar with moving around and inspecting the filesystem, let's look at how you can save time using command history and quick recall tools. Click here to continue on to the next section.</p>"},{"location":"03_command_history/","title":"Command History and Quick Recall Tools","text":"<p>Typing the same long commands over and over can get tedious and error prone. Fortunately, Unix shells keep a command history that lets you easily recall, repeat, and modify previous commands. This section covers essential shortcuts and tools to speed up your workflow.</p>"},{"location":"03_command_history/#basic-history-navigation","title":"Basic History Navigation","text":"<ul> <li> <p>Press the up arrow to scroll through previous commands.</p> </li> <li> <p>Press the down arrow to move forward again.</p> </li> </ul> <p>You can also view a full numbered history of your previous commands with:</p> <pre><code>history\n</code></pre>"},{"location":"03_command_history/#search-through-command-history","title":"Search Through Command History","text":"<p>You can use reverse search to find previous commands be substring. From the shell, press <code>CTRL+R</code> to begin a reverse search. You can then start typing part of the command, and the shell will search backward through your history.</p> <ul> <li> <p>Keep pressing <code>CTRL+R</code> to cycle through more matches.</p> </li> <li> <p>Press <code>Enter</code> to run the found command.</p> </li> <li> <p>Press <code>Esc</code> or <code>CTRL+G</code> to cancel the search.</p> </li> </ul> <p>Tip: Use <code>CTRL+S</code> to search forward</p>"},{"location":"03_command_history/#repeating-previous-commands-with-fish","title":"Repeating Previous Commands with Fish","text":"<p>The Fish shell offers even more intuitive and powerful history navigation tools. You can download Fish by following this link to the official site, or in Unix, you can run the command:</p> <pre><code>sudo apt install fish\n</code></pre> <p>Once installed, you only need to enter <code>fish</code> into your current shell to try it out. </p> <p>With the Fish shell, you're able to start typing any part of a previous command, and the shell will automatically suggest matching commands from your history. You can then press the up arrow to cycle through earlier commands, or press the right arrow to accept the suggestion, and then press Enter to run the command.</p> <p>Fish also includes advanced history commands:</p> <ul> <li> <p><code>history search &lt;pattern&gt;</code> shows matching commands.</p> </li> <li> <p><code>history delete --prefix &lt;pattern&gt;</code> deletes entries from your history that start with a given prefix.</p> </li> </ul> <p>Note: Fish keeps history per session and per working directory, making it especially useful for project-based work.</p> <p>Fish also helpfully uses syntax highlighting as you type. For instance, by default, Fish will color invalid commands red as you write them, and underline valid file paths.</p>"},{"location":"03_command_history/#view-and-edit-commands-before-running","title":"View and Edit Commands Before Running","text":"<p>You can use <code>fc</code> (fix command) to open your previous command in your default editor, such as <code>nano</code>, <code>vim</code>, or <code>emacs</code>. This can be useful for making edits to long or complex commands before re-running them.</p> <p>Now that you can navigate and reuse your command history efficiently, we'll move on to file operations: copying, moving, renaming, and deleting files using the shell. Click here to continue on to the next section.</p>"},{"location":"04_file_operations/","title":"Working with Files: Copy, Move, and Remove","text":"<p>File operations are fundamental to using the Unix shell effectively. Whether you're managing project files, organizing backups, or scripting automation tasks, mastering a few essential commands can greatly streamline your workflow.</p>"},{"location":"04_file_operations/#creating-files-with-touch","title":"Creating files with <code>touch</code>","text":"<p>The <code>touch</code> command follows the basic format of:</p> <pre><code>touch [OPTION] FILE\n</code></pre> <p>The command updates the access and modification times of the selected file to the current time. It can also be used to create a new file if the <code>FILE</code> argument does not exist.</p>"},{"location":"04_file_operations/#useful-touch-options","title":"Useful <code>touch</code> Options","text":"<p>While there aren't options to influence the creation of a new file with <code>touch</code> (aside from not creating one using <code>-c</code> or <code>--no-create</code>), there are options to modify the access and modification times of an existing file, such as:</p> <ul> <li> <p><code>-a</code>: Change only the access time.</p> </li> <li> <p><code>-d [STRING]</code> or <code>--date=STRING</code>: Parse <code>STRING</code> and use it instead of the current time. </p> <p><code>STRING</code> must be in the format <code>[[CC]YY]MMDD</code>. If <code>YY</code> is specified but <code>CC</code> is not, a value for <code>YY</code> between 69 and 99 results in a <code>CC</code> value of 19. Otherwise, <code>CC</code> defaults to a value of 20. So, if you wanted to change the last modified date of a file to January 1st, 2018, you would use the command:</p> </li> </ul> <pre><code>touch -d 20180101 example.txt\n</code></pre> <ul> <li> <p><code>-h</code> or <code>--no-dereference</code>: This command affects symbolic links instead of referenced files.</p> </li> <li> <p><code>-m</code>: Changes the modification time to the current time.</p> </li> <li> <p><code>-t [STAMP]</code>: Parse a <code>STAMP</code> of the format <code>[[CC]YY]MMDDhhmm[.SS]</code> to be the new modification time.</p> <p>The same rules apply for the <code>[[CC]YY]MMDD</code> part of the argument. The <code>hh</code> argument uses a 24 hour clock (from 00 to 23). If you wished to change the modified date of a file to January 1st, 2018, at 5:28:30pm, you could use the command:</p> </li> </ul> <pre><code>touch -d 201801011728.30 example.txt\n</code></pre> <p>For more information on the basics of text editors which you can use to edit the contents of a file, you can follow this link to a short series of lessons on three of the most popular text editors, <code>nano</code>, <code>Vim</code>, and <code>Emacs</code>.</p>"},{"location":"04_file_operations/#making-folders-with-mkdir","title":"Making folders with <code>mkdir</code>","text":"<p>The <code>mkdir</code> command will create a new folder if one does not already exist. It follows the basic format of:</p> <pre><code>mkdir [OPTION] DIRECTORY\n</code></pre>"},{"location":"04_file_operations/#useful-mkdir-options","title":"Useful <code>mkdir</code> Options","text":"<ul> <li><code>-p</code> or <code>--parents</code>: Creates parent directories if necessary. For instance, running the following from a folder where <code>testdir</code> doesn't exist will create three total directories:</li> </ul> <pre><code>mkdir -p testdir/subdir/exampledir\n</code></pre> <ul> <li><code>-v</code>: Print a message for each created directory. This can be useful for automated scripts to show everything that gets created, potentially helping to find errors in directory creation.</li> </ul>"},{"location":"04_file_operations/#copying-files-with-cp","title":"Copying files with <code>cp</code>","text":"<p><code>cp</code> copies files or directories. The basic usage looks like:</p> <pre><code>cp [OPTION] SOURCE DEST\n</code></pre> <p>Where <code>SOURCE</code> and <code>DEST</code> would be the old and new filenames if you're copying the file to the same directory. For instance, if you're just copying a file to the same directory and changing its name, that would look like:</p> <pre><code>cp oldfile.txt backup.txt\n</code></pre> <p>You can also copy the original file into a new folder by setting <code>DEST</code> as the path, such as in:</p> <pre><code>mkdir testdir\ncp oldfile.txt testdir/\n</code></pre> <p>It is also possible to change the name of the copy in the same way:</p> <pre><code>cp oldfile.txt tesdir/backup.txt\n</code></pre>"},{"location":"04_file_operations/#useful-cp-options","title":"Useful <code>cp</code> Options","text":"<p>There are several common options to use with the copy command. These include:</p> <ul> <li> <p><code>-f</code> or <code>--force</code>: If an existing destination file cannot be opened, remove it and try again.</p> </li> <li> <p><code>-n</code> or <code>--no-clobber</code>: Prevents you from overwriting an existing file.</p> </li> <li> <p><code>-i</code> or <code>--interactive</code>: Prompts you for confirmation before overwriting an existing file.</p> </li> </ul> <p>Note that <code>-n</code> and <code>-i</code> will override each other. Only the second one will be used.</p> <ul> <li> <p><code>-R</code>, <code>-r</code>, or <code>--recursive</code>: Option required to copy a directory. </p> </li> <li> <p><code>-s</code> or <code>--symbolic-link</code>: Makes a symbolic link instead of copying the file. A symbolic link is similar to a shortcut, differing from copying in that changes to the original will effect the symbolic link version of the file as well, while copying creates an independant version of the file.</p> </li> </ul>"},{"location":"04_file_operations/#move-or-rename-files-with-mv","title":"Move or rename files with <code>mv</code>","text":"<p><code>mv</code> moves files if the target is a directory or renames them if the target includes a new name. This command differs from copying in that only one version of the file or directory is preserved. However the command is otherwise very similar, following the basic usage of:</p> <pre><code>mv [OPTION] SOURCE DEST\n</code></pre> <p>For instance, if you want to move a file to a new directory, you can use:</p> <pre><code>mv oldfile.txt testdir/\n</code></pre> <p>If you wish to rename it in the process:</p> <pre><code>mv oldfile.txt testdir/newname.txt\n</code></pre> <p>If you only wish to rename the file while keeping it in the same directory:</p> <pre><code>mv oldfile.txt newname.txt\n</code></pre>"},{"location":"04_file_operations/#useful-mv-options","title":"Useful <code>mv</code> Options","text":"<p>Some of the options are also the same as in the copy command, including:</p> <ul> <li> <p><code>-f</code>, <code>--force</code></p> </li> <li> <p><code>-i</code>, <code>--interactive</code>, and</p> </li> <li> <p><code>-n</code>, <code>--no-clobber</code></p> </li> </ul> <p>The other suggested options that are available in copy (<code>-R</code>, <code>-r</code>, <code>--recursive</code>, <code>-s</code>, and <code>--symbolic-link</code>) are not available for the <code>mv</code> command. </p>"},{"location":"04_file_operations/#delete-files-with-rm","title":"Delete files with <code>rm</code>","text":"<p><code>rm</code> deletes/unlinks files or folders, so use this option with caution. Its basic usage follows the format of:</p> <pre><code>rm [OPTION] FILE\n</code></pre> <p>Like with <code>cp</code> and <code>mv</code>, the <code>FILE</code> argument can be a path to a specific file outside of the directory that your shell is inside of.</p>"},{"location":"04_file_operations/#useful-rm-options","title":"Useful <code>rm</code> Options","text":"<ul> <li> <p><code>-f</code> or <code>--force</code>: Ignores nonexistent files and arguments.</p> </li> <li> <p><code>-i</code>: Prompts the user for confirmation before every removal.</p> </li> <li> <p><code>-I</code>: Prompts the user for confirmation if trying to remove more than three files, or when removing recursively. This is useful for automated scripts.</p> </li> <li> <p><code>-r</code>, -<code>R</code>, or <code>--recursive</code>: Remove directories and their contents.</p> </li> <li> <p><code>-d</code> or <code>--dir</code>: Removes empty directories.</p> </li> </ul>"},{"location":"04_file_operations/#destroy-files-with-shred","title":"Destroy files with <code>shred</code>","text":"<p><code>shred</code> is similar to <code>rm</code> in that it makes files unusable, but <code>shred</code> repeatedly overwrites the content, making it unrecoverable. Think of <code>rm</code> as like sending a file to your recycle bin, while <code>shred</code> is more like corrupting a file. It is still possible to recover files that have been removed with <code>rm</code> if you know what you're doing, but it is incredibly difficult to recover files that you <code>shred</code>, even using expensive hardware. Its basic usage follows the format of:</p> <pre><code>shred [OPTION] FILE\n</code></pre> <p>When you <code>shred</code> a file, there will still be a file with the given name and extension, but its contents will be unrecognizable. To demonstrate, try making an example file with a text editor:</p> <pre><code>nano example.txt\n</code></pre> <p>Then, write something to the file, save and quit (<code>CTRL+X</code> \\(\\to\\) <code>Y</code> \\(\\to\\) <code>Enter</code>), and <code>shred</code> the file.</p> <pre><code>shred example.txt\n</code></pre> <p>You can then run the command <code>nano example.txt</code> to open the file in your shell to see that your message has been transformed into a jumble of ASCII text.</p>"},{"location":"04_file_operations/#useful-shred-options","title":"Useful Shred Options","text":"<ul> <li> <p><code>-f</code> or <code>--force</code>: Changes permissions to allow writing to the file.</p> </li> <li> <p><code>-n</code> or <code>--iterations=N</code>: By default, <code>shred</code> will overwrite the file 3 times. This option allows you to specify how many times, N, to overwrite the file, making it potentially easier or more difficult to recover the data.</p> </li> <li> <p><code>-s</code> or <code>--size=N</code>: Allows you to specify a number, N, of bytes to overwrite.</p> </li> <li> <p><code>-u</code>: Remove file after overwriting it.</p> </li> <li> <p><code>-z</code> or <code>--zero</code>: Add a final overwrite with zeros to hide the shredding.</p> </li> </ul> <p>Now that you have a handle on creating, moving, and entering files and directories, click here to continue to the next section where we can start creating some example files to practice searching with.</p>"},{"location":"05_creating_example_files/","title":"Creating Example Files","text":"<p>Now that we've gotten some of the more vital commands down, let's use this as an opportunity to start creating some files that we can test our command knowledge on. This will also help us in future sections to test new commands on. </p> <p>This section will show the explicit creation of three example files, but you can also simply download the three created files with the following links and move them to a directory of your choice:</p> <ul> <li> <p>planets.csv</p> </li> <li> <p>constellations.csv</p> </li> <li> <p>galaxies.csv</p> </li> </ul> <p>If you're creating your files, navigate to a folder that you'd be willing to use for this lesson by using the <code>cd</code> command. To get to your home directory, you can use:</p> <pre><code>cd ~\n</code></pre> <p>From there, create a new folder which can be used to house your example files:</p> <pre><code>mkdir Unix-Tips\n</code></pre> <p>Then, enter this directory using:</p> <pre><code>cd Unix-Tips\n</code></pre> <p>Now let's create and edit some files using the <code>touch</code> command and a text editor of your choice. This lesson will be using the <code>nano</code> editor. We'll want to create some files that have several lines with distinct words or phrases for the later sections which will focus on editing and searching. For this example, we'll be creating a couple of files with astronomical data:</p> <pre><code>touch planets.csv\ntouch constellations.csv\ntouch galaxies.csv\n</code></pre> <p>Let's start by creating our <code>planets.csv</code> file. We'll create one line for each planet and include its radius, distance from the sun, and mass. Start by entering:</p> <pre><code>nano planets.csv\n</code></pre> <p>Then, inside the file, we can add our information:</p> <p>Planet, Radius (m), Distance (AU), Mass (Kg),</p> <p>Mercury, 2.44E6, 0.39, 3.29E23,</p> <p>Venus, 6.05E6, 0.72, 4.87E24,</p> <p>Earth, 6.37E6, 1, 5.97E24,</p> <p>Mars, 3.39E6, 1.52, 6.42E23,</p> <p>Jupiter, 7.15E7, 5.2, 1.90E27,</p> <p>Saturn, 6.03E7, 9.54, 5.69E26,</p> <p>Uranus, 2.56E7, 19.2, 8.68E25,</p> <p>Neptune, 2.48E7, 30.1, 1.02E26</p> <p>Note: The text here is double spaced as a result of the markdown filetype requirments for line breaks.</p> <p>Then save and exit the file using <code>CTRL+X</code> and <code>Y</code> before creating data for the second two files:</p> <pre><code>nano constellations.csv\n</code></pre> <p>With data from the Zodiac constellations:</p> <p>Constellation, Brightest Star,</p> <p>Aries, Hamal,</p> <p>Taurus, Aldebaran,</p> <p>Gemini, Pollux,</p> <p>Cancer, Al Tarf,</p> <p>Leo, Regulus,</p> <p>Virgo, Spica,</p> <p>Libra, Zubeneschamali,</p> <p>Scorpius, Antares,</p> <p>Ophiuchus, Rasalhague,</p> <p>Sagittarius, Kaus Australis,</p> <p>Capricornus, Deneb Algedi,</p> <p>Aquarius, Sadalsuud,</p> <p>Pisces, Alpherg</p> <p>And finally, let's fill galaxies.csv with a small selection of galaxies in our local group:</p> <pre><code>nano galaxies.csv\n</code></pre> <p>Galaxy, Constellation, Type,</p> <p>Andromeda, Andromeda, Spiral,</p> <p>Milky Way (Center), Sagittarius, Spiral,</p> <p>Triangulum, Triangulum, Spiral,</p> <p>Pisces Dwarf, Pisces, Irregular,</p> <p>Leo A, Leo, Irregular</p> <p>Now, let's create some directories inside <code>Unix-Tips</code> so that we can better test some of the commands from the next sections:</p> <pre><code>mkdir local-universe\nmkdir local-universe/milky-way\n</code></pre> <p>It's now only a couple commands to move our files into their respective directories:</p> <pre><code>mv planets.csv local-universe/milky-way\nmv constellations.csv local-universe/milky-way\nmv galaxies.csv local-universe/\n</code></pre> <p>You should now have a file tree similar to:</p> <pre><code>Unix-Tips\n    \u2514\u2500\u2500 local-universe\n        \u251c\u2500\u2500 galaxies.csv\n        \u2514\u2500\u2500 milky-way\n            \u251c\u2500\u2500 constellations.csv\n            \u2514\u2500\u2500 planets.csv\n</code></pre> <p>Now that we have some examples, click here to continue to the next section where we can learn some powerful tools that can be used to search for files.</p>"},{"location":"06_searching_for_files/","title":"Using <code>find</code> to Search Filenames","text":"<p>The <code>find</code> command recursively searches for files by name, type, size, or modification time. By default, the command prints the names of the files for which your entire expression is <code>true</code>, unless your expression contains an action besides <code>-prune</code> or <code>-quit</code>. </p> <p><code>find</code> searches your directory tree rooted from a given starting point, evaluating your entire expression from left to right until the outcome is determined as <code>True</code> or <code>False</code>, at which point <code>find</code> moves on to the next file (unless using the <code>-quit</code> argument). Without a specified search root, the current directory, <code>.</code>, is assumed. Also, if a starting point argument would normally begin with <code>-</code>, <code>find</code> would try to treat it instead as an expression. For this reason, it is generally safer to prefix any wildcard or dubius path names with <code>./</code>, or to use absolute paths such as <code>/home/user/Unix-Tips</code>.</p> <p>The <code>find</code> command follows the format:</p> <pre><code>find [path...] [expression]\n</code></pre> <p>The <code>expressions</code> used to select files are comprised of one or more of the four primaries: <code>options</code>, <code>tests</code>, <code>actions</code>, and <code>operators</code>. </p> <p>If you're not already, let's move into the <code>Unix-Tips</code> directory to practice some of these expressions.</p> <pre><code>cd Unix-Tips\n</code></pre>"},{"location":"06_searching_for_files/#1-options","title":"1. <code>options</code>","text":"<p>These affect the overall operation. Where to search instead of what to search. Let's look at some of the most common <code>options</code>:</p>"},{"location":"06_searching_for_files/#-maxdepth-n","title":"<code>-maxdepth [N]</code>","text":"<p>Limits how many subdirectories deep your expression will search starting from the search root.</p> <pre><code>find . -maxdepth 3 -name \"*.csv\"\n</code></pre> <p>Output</p> <pre><code>./local-universe/galaxies.csv\n./local-universe/milky-way/constellations.csv\n./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#-mindepth-n","title":"<code>-mindepth [N]</code>","text":"<p>Skips a number of directory levels before applying tests.</p> <pre><code>find . -mindepth 3 -name \"*.csv\"\n</code></pre> <p>Output:</p> <pre><code>./local-universe/milky-way/constellations.csv\n./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#-depth","title":"<code>-depth</code>","text":"<p>Processes directory contents starting from current directory without leaving behind empty directories or causing accidental deletion issues.</p> <pre><code>find . -depth -name \"*.csv\"\n</code></pre> <p>Output:</p> <pre><code>./local-universe/galaxies.csv\n./local-universe/milky-way/constellations.csv\n./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#-xdev-mount","title":"<code>-xdev</code>/<code>-mount</code>","text":"<p>Prevents find from descending into directories that are on different filesystems than the starting point. This is especially useful when you're searching from a top-level directory like <code>/</code>, and you want to avoid scanning mounted drives, network shares, or other partitions (e.g., <code>/proc</code>, <code>/mnt</code>, <code>/media</code>, etc.).</p>"},{"location":"06_searching_for_files/#2-tests","title":"2. <code>tests</code>","text":"<p>These return a true or false value depending on the file's attributes. Here are some examples for the most common <code>find</code> <code>tests</code>:</p>"},{"location":"06_searching_for_files/#-name-pattern-iname-pattern","title":"<code>-name PATTERN</code>/<code>-iname PATTERN</code>","text":"<p>Matches files by name. <code>-iname</code> is case-insensitive. Wildcards like <code>*</code> and <code>?</code> are supported.</p> <pre><code>find . -name \"planets*\"\n</code></pre> <p>Output:</p> <pre><code>./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#-type","title":"<code>-type</code>","text":"<p>Matches by file type: * <code>f</code>: Regular file * <code>d</code>: Directory * <code>l</code>: Symbolic link</p> <pre><code>find . -type d\n</code></pre> <p>Output:</p> <pre><code>.\n./local-universe\n./local-universe/milky-way\n</code></pre>"},{"location":"06_searching_for_files/#-mtime-n-mmin-n","title":"<code>-mtime N</code>/<code>-mmin N</code>","text":"<p>Matches files by modification time. <code>-mtime</code> uses days, <code>-mmin</code> uses minutes. Let's say I've recently edited <code>galaxies.csv</code>, but none of the other files:</p> <pre><code>find . -mtime -1 # Find files modified in the last day\nfind . -mmin +60 # Find files modified more than an hour ago\n</code></pre> <p>Output:</p> <pre><code>.\n./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>.\n./local-universe\n./local-universe/milky-way\n./local-universe/milky-way/constellations.csv\n./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#-size-nbckmg","title":"<code>-size N[b|c|k|M|G]</code>","text":"<p>Matches files by size. * <code>b</code>: 512-byte blocks * <code>c</code>: bytes * <code>k</code>: Kb * <code>M</code>: Mb * <code>G</code>: Gb</p> <pre><code>find . -size +10M  # Find files larger than 10 Mb\nfind . -size -100k # Find files smaller than 100 Kb\nfind . -size 3b    # Find files that are exactly 3 blocks\n</code></pre>"},{"location":"06_searching_for_files/#-user-name-group-name","title":"<code>-user NAME</code>/<code>-group NAME</code>","text":"<p>Find files owned by a specific user or group.</p> <pre><code>find /home -user admin # Find files owned by user named admin\n</code></pre> <p><code>-nouser</code> and <code>-nogroup</code> can be used to find files with no associated user or group. Those commands are often used for deleted accounts. </p>"},{"location":"06_searching_for_files/#-empty","title":"<code>-empty</code>","text":"<p>Match empty files or directories</p> <pre><code>find . -type f -empty # Find empty files\nfind . -type d -empty # Find empty directories\n</code></pre>"},{"location":"06_searching_for_files/#-path-wholename","title":"<code>-path</code>/<code>-wholename</code>","text":"<p>Match full relative path (from search root)</p> <pre><code>find . -path \"./local-universe/milky-way/*.csv\"\n</code></pre> <p>Output:</p> <pre><code>./local-universe/milky-way/constellations.csv\n./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#-newer-file-anewer-file-cnewer-file","title":"<code>-newer FILE</code>/<code>-anewer FILE</code>/<code>-cnewer FILE</code>","text":"<p>Match files based on their modified/access/change times respectively.</p> <pre><code>find . -newer constellations.csv\n</code></pre> <p>Output:</p> <pre><code>.\n./local-universe\n./local-universe/galaxies.csv\n./local-universe/milky-way\n</code></pre>"},{"location":"06_searching_for_files/#-readable-writable-executable","title":"<code>-readable</code>/<code>-writable</code>/<code>-executable</code>","text":"<p>Checks the accessibilities for the current user.</p> <pre><code>find . -type f -writable\n</code></pre> <p>Output:</p> <pre><code>./local-universe/galaxies.csv\n./local-universe/milky-way/constellations.csv\n./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#3-actions","title":"3. <code>actions</code>","text":"<p>These have side effects, but otherwise also return a true or false value. Here are some examples of the most common <code>find</code> <code>actions</code>:</p>"},{"location":"06_searching_for_files/#-print","title":"<code>-print</code>","text":"<p>This is a default action which does not need to be specified. <code>-print</code> prints the patch of each file which matches the rest of the expression.</p>"},{"location":"06_searching_for_files/#-fprint-file","title":"<code>-fprint FILE</code>","text":"<p>This prints the entire file name into a given <code>FILE</code> followed by a newline. This will also create the <code>FILE</code> if it does not already exist.</p> <pre><code>find . -name \"*.csv\" -fprint ./csv_list.txt \n</code></pre> <p>This command creates a new file named \"csv_list.txt\" which contains a list of all the .csv files.</p>"},{"location":"06_searching_for_files/#-delete","title":"<code>-delete</code>","text":"<p>Deletes each file which matches the expression: Use with caution. This command is often combined with <code>-type</code> to avoid deleting directories or special files by accident.</p> <pre><code>find ./Unix-Tips -name \"*.txt\" -delete \n</code></pre>"},{"location":"06_searching_for_files/#-exec-command","title":"<code>-exec COMMAND {} \\;</code>","text":"<p>Runs a command for each matching file. The shell substitutes <code>{}</code> with the full path to the file when running. <code>\\;</code> then terminates the command.</p> <p>You can also replace <code>\\;</code> with <code>+</code> to have the command run once with multiple file arguments instead of once per file.</p> <pre><code>find . -name \"*.txt\" -exec gzip {} \\;\n</code></pre>"},{"location":"06_searching_for_files/#-prune","title":"<code>-prune</code>","text":"<p>Stops <code>find</code> from descending into matching directories. This action is common for skipping paths.</p> <pre><code>find local-universe -path \"local-universe/milky-way\" -prune -o -name \"*.csv\" \n</code></pre> <p>Output:</p> <pre><code>local-universe/galaxies.csv\nlocal-universe/milky-way\n</code></pre>"},{"location":"06_searching_for_files/#-quit","title":"<code>-quit</code>","text":"<p>Stops after the first match. Useful for fast existence checks.</p> <pre><code>find . -name \"*.csv\" -print -quit\n</code></pre> <p>Output:</p> <pre><code>./local-universe/galaxies.csv\n</code></pre>"},{"location":"06_searching_for_files/#less-common-actions-that-are-still-useful-in-scripts","title":"Less common <code>actions</code> that are still useful in scripts:","text":""},{"location":"06_searching_for_files/#-print0-and-fprint0-file","title":"<code>-print0</code> and <code>-fprint0 FILE</code>","text":"<p>Prints filenames with a null character instead of a newline. This action is ideal for filenames which include spaces.</p>"},{"location":"06_searching_for_files/#-ls","title":"<code>-ls</code>","text":"<p>Prints <code>ls -dils</code> style info for each file.</p>"},{"location":"06_searching_for_files/#-ok-command","title":"<code>-ok COMMAND ;</code>","text":"<p>Like <code>-exec</code>, but prompts for confirmation before running each command.</p>"},{"location":"06_searching_for_files/#-execdir-okdir","title":"<code>-execdir</code>, <code>-okdir</code>","text":"<p>Like <code>-exec</code>, but runs the command in the directory of the matching file instead of where <code>find</code> was run. Useful when the command depends on relative paths.</p>"},{"location":"06_searching_for_files/#4-operators","title":"4. <code>operators</code>:","text":"<p><code>find</code> allows for you to combine multiple tests using logical operators such as AND, OR, and NOT. These combinations can then also be grouped with parentheses. <code>operators</code> can be very powerful for creating more precise search expressions:</p>"},{"location":"06_searching_for_files/#-and-aspace","title":"<code>-and</code>/<code>-a</code>/space","text":"<p>All expressions must be true. This is the defualt behavior of <code>find</code>: listing conditions with spaces will automatically assume <code>-and</code>, but it can be writen explicitely.</p> <pre><code>find ./Unix-Tips -type f -and -name \"*.csv\"\n</code></pre>"},{"location":"06_searching_for_files/#-or-o","title":"<code>-or</code>/<code>-o</code>","text":"<p>Matches if either condition is true.</p> <pre><code>find . \\( -name \"galaxies.csv\" -or -name \"planets.csv\" \\)\n</code></pre> <p>Output:</p> <pre><code>./local-universe/galaxies.csv\n./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"06_searching_for_files/#-not","title":"<code>-not</code>/<code>!</code>","text":"<p>Inverts a test</p> <pre><code>find . -type f ! -name \"planets.csv\"\n</code></pre> <p>Output:</p> <pre><code>./local-universe/galaxies.csv\n./local-universe/milky-way/constellations.csv\n./csv_list.txt\n</code></pre>"},{"location":"06_searching_for_files/#grouping-using-and","title":"Grouping using <code>(</code> and <code>)</code>","text":"<p>Allows for the grouping of expressions. Must be escaped or quoted in most shells in order to avoid shell interpretation: <code>\\(...\\)</code> such as in the <code>-or</code> example.</p>"},{"location":"06_searching_for_files/#operation-precedence","title":"Operation Precedence","text":"<p><code>find</code> lists the precedence order for operators from highest to lowest as:</p> <ol> <li> <p><code>()</code></p> </li> <li> <p><code>!</code>/<code>-not</code></p> </li> <li> <p>Then <code>-and</code></p> </li> <li> <p>Then <code>-or</code></p> </li> </ol> <p>Now that we have a better handle on searching for specific files, click here to continue on to the next section to learn how to search for specific text inside of your files.</p>"},{"location":"07_searching_inside_files/","title":"Using <code>grep</code> to Search Inside Files","text":"<p>The <code>grep</code> command (a contraction of \"global/regular expression/print\") allows for searching through text files with commands to perform simple or recursive searches, while also allowing for multiple search terms, the ability to count matches, and even allowing users to pipe the output to other commands for further manipulation.</p> <p>The basic syntax of <code>grep</code> follows:</p> <pre><code>grep [OPTIONS] PATTERNS [FILES]\n</code></pre> <p><code>grep</code> will then search for the given <code>PATTERN</code> in each of the listed files, and then by default will simply print the related line. The available options for <code>grep</code> are separated into 4 different groups:</p>"},{"location":"07_searching_inside_files/#1-pattern-selection-and-interpretation","title":"1: Pattern Selection and Interpretation","text":"<p>These options define how <code>grep</code> understands and applies your search pattern, allowing you to switch between simple string matching and the more powerful regular expressions, as well as allowing you to control case sensitivity and match boundaries. The most common options you'll use here are:</p>"},{"location":"07_searching_inside_files/#-i-ignore-case","title":"<code>-i</code>/<code>--ignore-case</code>","text":"<p>Ignores case sensitivity.</p> <pre><code>grep -i 'spiral' ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>Andromeda, Andromeda, Spiral,\nMilky Way (Center), Sagittarius, Spiral,\nTriangulum, Triangulum, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-w-word-regexp","title":"<code>-w</code>/<code>--word-regexp</code>","text":"<p>Match with a whole word.</p> <pre><code>grep -w 'Al' ./local-universe/milky-way/constellations.csv\n</code></pre> <p>This will match the line containing \"Al Tarf\", while ignoring \"Aldebaran\".</p> <p>Output:</p> <pre><code>Cancer, Al Tarf,\n</code></pre>"},{"location":"07_searching_inside_files/#-e-extended-regexp","title":"<code>-E</code>/<code>--extended-regexp</code>","text":"<p>Allows your <code>PATTERN</code> to be interpreted as an extended regular expression. This allows for more complex syntax like <code>+</code>, <code>?</code>, and <code>|</code> without needing backslashes. For instance, to find entries that start with either \"A\" or \"S\":</p> <pre><code>grep -E '^(A|S)' ./local-universe/milky-way/constellations.csv\n</code></pre> <p>Output:</p> <pre><code>Aries, Hamal,\nScorpius, Antares,\nSagittarius, Kaus Australis,\nAquarius, Sadalsuud,\n</code></pre>"},{"location":"07_searching_inside_files/#-e-pattern-regexppattern","title":"<code>-e PATTERN</code>/<code>--regexp=PATTERN</code>","text":"<p>Search using multiple patterns.</p> <pre><code>grep -e 'Pisces' -e 'Taurus' ./local-universe/milky-way/constellations.csv\n</code></pre> <p>Output:</p> <pre><code>Taurus, Aldebaran,\nPisces, Alpherg\n</code></pre>"},{"location":"07_searching_inside_files/#-f-file-filefile","title":"<code>-f FILE</code>/<code>--file=FILE</code>","text":"<p>Loads one pattern per line, comparing each line against the given file.</p> <p>Let's say we know a couple of the brightest stars in some constellations, but don't know the names of the constellations themselves. We can create a pattern file:</p> <pre><code>nano pattern.txt\n</code></pre> <p>And then fill it with the stars we know:</p> <pre><code>Hamal\nAldebaran\nAl Tarf\nRasalhague\nDeneb Algedi\nAlpherg\n</code></pre> <p>Now you can use grep to find which lines contain those stars:</p> <pre><code>grep -f ./pattern.txt ./local-universe/milky-way/constellations.csv\n</code></pre> <p>Output:</p> <pre><code>Aries, Hamal,\nTaurus, Aldebaran,\nCancer, Al Tarf,\nOphiuchus, Rasalhague,\nCapricornus, Deneb Algedi,\nPisces, Alpherg\n</code></pre>"},{"location":"07_searching_inside_files/#-f-fixed-strings","title":"<code>-F</code>/<code>--fixed-strings</code>","text":"<p>Treats your pattern as a literal string instead of a regular expression. This is faster for simple, exact matches.</p>"},{"location":"07_searching_inside_files/#-g-basic-regexp","title":"<code>-G</code>/<code>--basic-regexp</code>","text":"<p>Uses basic regular expressions, and is the default mode of <code>grep</code> unless overridden by other options. Special characters require escaping with this option.</p>"},{"location":"07_searching_inside_files/#-no-ignore-case","title":"<code>--no-ignore-case</code>","text":"<p>Explicitly disable case-insensitive matching. This can be useful when searching for lines that might contain the same spelling but with different capitalisation, like <code>Leo Aa</code> vs <code>Leo AA</code>.</p>"},{"location":"07_searching_inside_files/#-x-line-regexp","title":"<code>-x</code>/<code>--line-regexp</code>","text":"<p>Matches entire lines exactly. </p>"},{"location":"07_searching_inside_files/#-z-null-data","title":"<code>-z</code>/<code>--null-data</code>","text":"<p>Treat input as null-delimited. This option is useful for special binary or structured formats. Each \"line\" ends in a null byte (<code>\\0</code>) instead of a newline.</p>"},{"location":"07_searching_inside_files/#2-miscellaneous","title":"2: Miscellaneous","text":"<p>These options don't directly affect how <code>grep</code> interprets or searches for patterns but help with controlling its behaviour, output, or interaction with the shell.</p>"},{"location":"07_searching_inside_files/#-s-no-messages","title":"<code>-s</code>/<code>--no-messages</code>","text":"<p>Suppresses error messages about unreadable files.</p>"},{"location":"07_searching_inside_files/#-v-invert-match","title":"<code>-v</code>/<code>--invert-match</code>","text":"<p>Selects lines that do not match the given pattern. Often used to exclude known entries or to filter out unwanted matches. For instance, let's say we want to invert the search from our <code>-f</code> example, <code>pattern.txt</code>.</p> <pre><code>grep -v -f pattern.txt ./local-universe/milky-way/constellations.csv\n</code></pre> <p>Output:</p> <pre><code>Constellation, Brightest Star,\nGemini, Pollux,\nLeo, Regulus,\nVirgo, Spica,\nLibra, Zubeneschamali,\nScorpius, Antares,\nSagittarius, Kaus Australis,\nAquarius, Sadalsuud,\n</code></pre>"},{"location":"07_searching_inside_files/#3-output-control","title":"3: Output Control","text":"<p>These options customize how <code>grep</code> displays its results. They are able to help you manage large outputs, script more effectively, and integrate with tools that expect specific formats.</p>"},{"location":"07_searching_inside_files/#-m-num-max-countnum","title":"<code>-m NUM</code>/<code>--max-count=NUM</code>","text":"<p>Stop reading a file after finding the first <code>NUM</code> matching lines.</p> <pre><code>grep -m 3 'ar' -i ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>Milky Way (Center), Sagittarius, Spiral,\nPisces Dwarf, Pisces, Irregular,\nLeo A, Leo, Irregular\n</code></pre>"},{"location":"07_searching_inside_files/#-b-byte-offset","title":"<code>-b</code>/<code>--byte-offset</code>","text":"<p>Prints the byte offset (position) of each matching line's start within the file.</p> <pre><code>grep -b 'Spiral' ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>29:Andromeda, Andromeda, Spiral,\n59:Milky Way (Center), Sagittarius, Spiral,\n100:Triangulum, Triangulum, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-n-line-number","title":"<code>-n</code>/<code>--line-number</code>","text":"<p>Show the line number for each match. This is especially helpful when working with large files.</p> <pre><code>grep -n 'Spiral' ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>2:Andromeda, Andromeda, Spiral,\n3:Milky Way (Center), Sagittarius, Spiral,\n4:Triangulum, Triangulum, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-line-buffered","title":"<code>--line-buffered</code>","text":"<p>Flushes output after every line instead of buffering. Useful for piping <code>grep</code> into tools that need live output.</p>"},{"location":"07_searching_inside_files/#-h-with-filename","title":"<code>-H</code>/<code>--with-filename</code>","text":"<p>Always show the file name in the output. This is a default option when multiple files are searched.</p> <pre><code>grep -H 'Spiral' ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>./local-universe/galaxies.csv:Andromeda, Andromeda, Spiral,\n./local-universe/galaxies.csv:Milky Way (Center), Sagittarius, Spiral,\n./local-universe/galaxies.csv:Triangulum, Triangulum, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-h-no-filename","title":"<code>-h</code>/<code>--no-filename</code>","text":"<p>Suppress the file name output, such as when searching for multiple files if you only care about the content, not which file the content is from.</p>"},{"location":"07_searching_inside_files/#-o-only-matching","title":"<code>-o</code>/<code>--only-matching</code>","text":"<p>Prints only the part of each line that matches the search pattern.</p> <pre><code>grep -o 'Spiral' ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>Spiral\nSpiral\nSpiral\n</code></pre>"},{"location":"07_searching_inside_files/#-q-quiet-silent","title":"<code>-q</code>/<code>--quiet</code>/<code>--silent</code>","text":"<p>Suppresses all normal outputs. This is useful for testing the presence or absence of a pattern in scripts.</p> <pre><code>grep -q 'Spiral' ./local-universe/galaxies.csv &amp;&amp; echo \"Spiral found.\"\n</code></pre> <p>Output:</p> <pre><code>Spiral found.\n</code></pre>"},{"location":"07_searching_inside_files/#-binary-filestype","title":"<code>--binary-files=TYPE</code>","text":"<p>Choose how to handle binary files. * <code>binary</code>: Treat as binary (default). * <code>text</code>: Treat as if plain text. * <code>without-match</code>: Silently skip binary files.</p> <p><code>a</code>/<code>--text</code> are equivalent to <code>--binary-files=text</code></p> <p><code>-I</code> is equivalent to <code>--binary-files=without-match</code></p>"},{"location":"07_searching_inside_files/#-d-action-directoriesaction","title":"<code>-d ACTION</code>/<code>--directories=ACTION</code>","text":"<p>Allows you to choose what to do with directories. * <code>read</code>: Read them as files. * <code>recurse</code>: Search inside of them recursively. * <code>skip</code>: Ignore them (this is the default unless <code>-r</code> is used).</p>"},{"location":"07_searching_inside_files/#-d-action-devicesaction","title":"<code>-D ACTION</code>/<code>--devices=ACTION</code>","text":"<p>Similar to <code>-d</code>, but for device files, FIFOs, or sockets.</p>"},{"location":"07_searching_inside_files/#-r-recursive","title":"<code>-r</code>/<code>--recursive</code>","text":"<p>Recursively searches subdirectories (does not follow symlinks).</p> <pre><code>grep -r 'Earth'\n</code></pre> <p>Output:</p> <pre><code>./local-universe/milky-way/planets.csv:Earth, 6.37E6, 1, 5.97E24,\n</code></pre>"},{"location":"07_searching_inside_files/#-r-dereference-recursive","title":"<code>-R</code>/<code>--dereference-recursive</code>","text":"<p>Like <code>-r</code>, but does follow symlinks.</p>"},{"location":"07_searching_inside_files/#-includeglob","title":"<code>--include=GLOB</code>","text":"<p>Restrict search to files matching a glob pattern. For instance, if you only wish to search inside of .txt files, you can run something like:</p> <pre><code>grep -r --include=\"*.txt\" 'Hamal'\n</code></pre> <p>Output:</p> <pre><code>pattern.txt:Hamal\n</code></pre>"},{"location":"07_searching_inside_files/#-excludeglob","title":"<code>--exclude=GLOB</code>","text":"<p>Skips files that match the pattern.</p>"},{"location":"07_searching_inside_files/#-exclude-fromfile","title":"<code>--exclude-from=FILE</code>","text":"<p>Read exclusion patterns (one per line) from a given file. Let's create a new file named <code>exclude-pattern.txt</code> and fill it with some files we want to avoid in a search:</p> <pre><code>nano exclude-pattern.txt\n</code></pre> <p>Which will then contain:</p> <pre><code>galaxies.csv\nplanets.csv\n</code></pre> <p>Then, if we wanted to use a recursive search to find only constellations with \"Leo\" in their names (skipping the Leo A galaxy), we could run:</p> <pre><code>grep -r --exclude-from=exclude-pattern.txt 'Leo'\n</code></pre> <p>Output:</p> <pre><code>local-universe/milky-way/constellations.csv:Leo, Regulus,\n</code></pre>"},{"location":"07_searching_inside_files/#-exclude-dirglob","title":"<code>--exclude-dir=GLOB</code>","text":"<p>Skip directories that match the pattern. To skip the `milky-way/' subdirectory, you could run:</p> <pre><code>grep -r --exclude-dir=\"milky-way\" 'Tri'\n</code></pre> <p>Output:</p> <pre><code>local-universe/galaxies.csv:Triangulum, Triangulum, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-l-files-without-match","title":"<code>-L</code>/<code>--files-without-match</code>","text":"<p>Prints the names of files that contain no matches. To find files that don't contain the word \"Spiral\", you could use:</p> <pre><code>grep -rL 'Spiral'\n</code></pre> <p>Output:</p> <pre><code>exclude-pattern.txt\nlocal-universe/milky-way/constellations.csv\nlocal-universe/milky-way/planets.csv\ncsv_list.txt\npattern.txt\n</code></pre>"},{"location":"07_searching_inside_files/#-l-files-with-matches","title":"<code>-l</code>/<code>--files-with-matches</code>","text":"<p>Prints the names of files with at least one match.</p> <pre><code>grep -rl 'Leo'\n</code></pre> <p>Output:</p> <pre><code>local-universe/galaxies.csv\nlocal-universe/milky-way/constellations.csv\n</code></pre>"},{"location":"07_searching_inside_files/#-c-count","title":"<code>-c</code>/<code>--count</code>","text":"<p>Prints a count of the number of matches per file instead returning the actual matches.</p> <pre><code>grep -rc 'Al'\n</code></pre> <p>Output:</p> <pre><code>exclude-pattern.txt:0\nlocal-universe/galaxies.csv:0\nlocal-universe/milky-way/constellations.csv:4\nlocal-universe/milky-way/planets.csv:0\ncsv_list.txt:0\npattern.txt:4\n</code></pre>"},{"location":"07_searching_inside_files/#-t-initial-tab","title":"<code>-T</code>/<code>--initial-tab</code>","text":"<p>Align fields properly if tab characters are present in the output.</p>"},{"location":"07_searching_inside_files/#-z-null","title":"<code>-Z</code>/<code>--null</code>","text":"<p>Output a null character (<code>\\0</code>) after file names. This can be useful when filenames contain spaces or newlines.</p>"},{"location":"07_searching_inside_files/#4-context-control","title":"4: Context Control","text":"<p>When searching for a pattern in a file, sometimes the goal is to see not just the matching line, but also the surrounding context. <code>grep</code> provides a set of options to include lines before or after matches, which can be especially helpful in logs, source code, or debugging outputs.</p>"},{"location":"07_searching_inside_files/#-b-num-before-contextnum","title":"<code>-B NUM</code>/<code>--before-context=NUM</code>","text":"<p>Show <code>NUM</code> lines before each match.</p> <pre><code>grep -B 1 \"Andromeda\" ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>local-universe/galaxies.csv-Galaxy, Constellation, Type,\nlocal-universe/galaxies.csv:Andromeda, Andromeda, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-a-num-after-contextnum","title":"<code>-A NUM</code>/<code>--after-context=NUM</code>","text":"<p>Show <code>NUM</code> lines after each match.</p> <pre><code>grep -A 1 \"Andromeda\" ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>Andromeda, Andromeda, Spiral,\nMilky Way (Center), Sagittarius, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-c-num-contextnum-num","title":"<code>-C NUM</code>/<code>--context=NUM</code>/<code>-NUM</code>","text":"<p>Show <code>NUM</code> lines before and after each match.</p> <pre><code>grep -C 1 \"Andromeda\" ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>Galaxy, Constellation, Type,\nAndromeda, Andromeda, Spiral,\nMilky Way (Center), Sagittarius, Spiral,\n</code></pre>"},{"location":"07_searching_inside_files/#-group-separatorsep","title":"<code>--group-separator=SEP</code>","text":"<p>Insert <code>SEP</code> between blocks of matches when context is shown. Default is <code>--</code>.</p>"},{"location":"07_searching_inside_files/#-no-group-separator","title":"<code>--no-group-separator</code>","text":"<p>Suppresses the line between context-separated match blocks entirely.</p> <p>These options are useful when post-processing <code>grep</code> output and want consistent formatting or no interruptions between context groups.</p>"},{"location":"07_searching_inside_files/#-colorwhen-colourwhen","title":"<code>--color[=WHEN]</code>/<code>--colour[=WHEN]</code>","text":"<p>Highlight matching text using ANSI escape sequences. <code>WHEN</code> can be: * <code>always</code>: Force color, even when not writing to a terminal. * <code>never</code>: Disable color. * <code>auto</code>: Color only if output goes to a terminal.</p> <p>Most modern terminal setups default to <code>--color=auto</code>.</p>"},{"location":"07_searching_inside_files/#-u-binary","title":"<code>-U</code>/<code>--binary</code>","text":"<p>Disable stripping of <code>\\r</code> (carriage return) characters at the end of lines. This is useful when dealing with files from Windows systems (CRLF line endings). This option helps preserve exact formatting in mixed-platform environments.</p> <p>Now that we understand better how to search within files, let's learn how we can edit files from the command shell. Click here to continue on to the next section.</p>"},{"location":"08_editing_files/","title":"Editing Files with <code>sed</code> and <code>ed</code>","text":"<p>While graphical or full-screen editors like <code>nano</code>, <code>vim</code>, and <code>emacs</code> are interactive, Unix also provides stream-based and line-based editors that are ideal for scripting or batch processing. Two of the most powerful tools for this are <code>sed</code> and <code>ed</code>.</p>"},{"location":"08_editing_files/#using-sed","title":"Using <code>sed</code>","text":"<p><code>sed</code> works by reading a file line-by-line and applying transformation rules, often in the form of substitutions, deletions, or insertions. It is especially useful for making changes to large files or automating repetitive edits.</p> <p>The basic syntax of <code>sed</code> follows:</p> <pre><code>sed [OPTIONS] 'COMMANDS' filename\n</code></pre> <p>When replacing/substituting text using <code>sed</code>, the general format of the <code>'COMMAND'</code> should follow:</p> <pre><code>'s/pattern/replacement/[flags]'\n</code></pre> <p>Here, <code>s</code> stands for substitute. This tells <code>sed</code> that the goal is to search and replace. The <code>pattern</code> can then be a word, regex, or a complex pattern. The <code>replacement</code> is then what you are telling <code>sed</code> to replace the <code>pattern</code> with. Finally, <code>[flags]</code> represents the optional modifiers: | Flag       | Meaning                                 | |:---        |  ---                                    | |<code>g</code>         | Global - replace all matches            | |<code>1,2,...</code>   | Replace only the nth match              | |<code>p</code>         | Print only the substituded line         | |<code>I</code>         | Ignore case while searching             | |<code>e</code>         | Substitude and execute the command line |</p> <p>If you don't use one of the <code>flags</code> (i.e 's/pattern/replacement/'), it will only replace the first match. You can also use multiple flags in conjunction with one another. For instance, if you wanted to go line by line and replace every instance of a pattern after the third, while also ignoring case, you could use the flag <code>3Ig</code>. For clarity: this would not go from the third in the file on, but from the third in the line on, resetting with each new line. </p> <p>Let's take a look at how to use some of the more common <code>OPTIONS</code>:</p>"},{"location":"08_editing_files/#-isuffix-in-placesuffix","title":"<code>-i[SUFFIX]</code>/<code>--in-place[SUFFIX]</code>","text":"<p>This is one of the more vital options, and will often be used alongside others. It allows you to edit files in place, and can also make a backup of the file before creating a change if given the optional <code>SUFFIX</code>. Without including <code>-i</code>, this option will will simply print what given lines would look like if they were edited.</p> <p>Let's say we want to make an edit to our <code>planets.csv</code> file to have more explicit column names as well. Let's edit the title \"Planets\" to instead be \"Planet Names\" while also creating a <code>.bak</code> backup version of the file. <code>sed</code> can accomplish this with the expression:</p> <pre><code>sed -i.bak 's/Planet/Planet Name/' ./local-universe/milky-way/planets.csv\n</code></pre> <p>After running this, you will then have a new file named <code>planets.csv.bak</code> with the original version of the file, while the change \"Planet\" \\(\\to\\) \"Planet Name\" will be reflected in <code>planets.csv</code>.</p>"},{"location":"08_editing_files/#-n-quiet-silent","title":"<code>-n</code>/<code>--quiet</code>/<code>--silent</code>","text":"<p>This option supresses the automatic printing of duplicate rows which can be generated by other flags. If used with the <code>/p</code> flag, this option will print only the targeted lines. Let's say you want to preview an edit to <code>galaxies.csv</code> where it is more explicit with the column names, changing \"Types\" to \"Galaxies Types\". You could run:</p> <pre><code>sed -n 's/Type/Galaxy Type/p' ./local-universe/galaxies.csv\n</code></pre> <p>Output:</p> <pre><code>Galaxy, Constellation, Galaxy Type,\n</code></pre> <p>If you tried to add <code>-i</code> to this expression, it would result in a file that contains only the output line. To edit the line in the file, you would want to remove both <code>-n</code> and <code>/p</code>.</p>"},{"location":"08_editing_files/#-e-script-expressionscript","title":"<code>-e script</code>/<code>--expression=script</code>","text":"<p>These options allows for us to chain together multiple expressions. Let's say we want to convert the units of the planet radii from <code>m</code> to <code>km</code>. As the planets are all expressed with a radius of either \\(x \\times 10^6\\)m (xE6) or \\(x \\times 10^7\\)m (xE7), we could run the following three expressions to make this change:</p> <pre><code>sed -i -e 's/(m)/(km)/' -e 's/E6/E3/g' -e 's/E7/E4/g' ./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"08_editing_files/#-f-script-file-filescript-file","title":"<code>-f script-file</code>/<code>--file=script-file</code>","text":"<p>Instead of using <code>-e</code>, we can instead create a script file to read commands. This can be useful for when the number of edits you're trying to make would be cumbersome to type out directly in the command line. Let's say we want to represent the mass of all of the planets in metric tons instead of kilograms (1000 Kg = 1T). We can create a file and fill it with the relevant replacement commands:</p> <pre><code>nano kilogram-replacement.txt\n</code></pre> <pre><code>s/(Kg)/(T)/\ns/E23/E20/g\ns/E24/E21/g\ns/E25/E22/g\ns/E26/E23/g\ns/E27/E24/g\n</code></pre> <p>We can then run the expression:</p> <pre><code>sed -i -f kilogram-replacement.txt ./local-universe/milky-way/planets.csv\n</code></pre>"},{"location":"08_editing_files/#-e-r-regexp-extended","title":"<code>-E</code>/<code>-r</code>/<code>--regexp-extended</code>","text":"<p>These allow for the use of extended regular expressions.</p>"},{"location":"08_editing_files/#-s-separate","title":"<code>-s</code>/<code>--separate</code>","text":"<p>These allow for you to use multiple input files while also treating them as separate inputs. Without it, multiple input files can still be used, but will be treated as one longer stream.</p> <pre><code>sed -n -s '/Leo/p' ./local-universe/galaxies.csv ./local-universe/milky-way/constellations.csv\n</code></pre> <p>Output:</p> <pre><code>Leo A, Leo, Irregular\nLeo, Regulus,\n</code></pre>"},{"location":"08_editing_files/#using-ed","title":"Using <code>ed</code>","text":"<p>The <code>ed</code> line editor was one of the three original elements of the Unix system (assembler, editor, and shell), and can be used as a more surgical tool for editing files line-by-line. It's especially useful when you know or can find out the exact line numbers you wish to edit or when you want to script out precise edits. For most purposes however, <code>ed</code> is less useful than text-editors such as <code>nano</code> or <code>vim</code>, but it can be very efficient for specific uses with enough planning and forethought.</p> <p>Editing with <code>ed</code> is accomplished in two distinct modes: command and input. </p> <p>Command mode is the default mode when <code>ed</code> is initially invoked. From here, commands are read from the standard input and executed to manipulate the contents of the file. All commands operate on whole lines or ranges of lines. </p> <p>You can then enter input mode by inputting a command, such as <code>a</code> (append), <code>i</code> (insert), <code>d</code> (delete), or <code>c</code> (change). No commands are available in this mode, and input mode can then be terminated by entering a single period (<code>.</code>) on a line. If using <code>ed</code> to write a new file, you might use <code>a</code> to begin writing a line before ending the line by pressing <code>.</code>.</p> <p>The format for running <code>ed</code> follows:</p> <pre><code>ed [OPTIONS] [[+line] file]\ned [OPTIONS] [[+line] '!command [arguments]']\n</code></pre> <p>If the given <code>file</code> starts with a <code>!</code>, then it is interpreted as a shell command, meaning it will read the standard output of the <code>file</code> as if it was executed via the shell. If the file's name begins with a <code>!</code> then (and isn't filled with commands you want to run), simply prefix the name with <code>./</code>. </p>"},{"location":"08_editing_files/#addressing-lines-in-ed","title":"Addressing Lines in <code>ed</code>","text":"<p>The file name can also be preceded by <code>+line</code> to set the current line to a specified line number (such as <code>1</code>). This will default to the last line if the number given exceeds the number of lines in the file. It is also important to note that <code>ed</code> indexes lines starting from <code>1</code> instead of <code>0</code>.</p> <p>The <code>file</code> may also be preceded by <code>+/re</code> instead of the line number in order to set the current line as the first line which matches a given regular expression, <code>re</code>. <code>?re</code> sets the current line to the final line which matches the given regular expression.</p> <p>To summarize, most <code>ed</code> commands operate on <code>line</code> addresses. These can look like:</p> <ul> <li> <p>A specific line number: <code>5</code></p> </li> <li> <p>A range of lines: <code>1,5</code></p> </li> <li> <p>The current line: <code>.</code></p> </li> <li> <p>The last line: <code>$</code></p> </li> <li> <p>Relative lines: <code>.-1</code>, <code>.+2</code></p> </li> <li> <p>A regex match: <code>/pattern/</code> (forward), <code>?pattern?</code> (backwards)</p> </li> </ul>"},{"location":"08_editing_files/#basic-commands","title":"Basic Commands","text":"Command Meaning <code>a</code> Append text after current line <code>i</code> Insert text before current line <code>d</code> Delete current line <code>p</code> Print current line <code>w</code> Write the buffer to a file <code>q</code> Quit the editor ### Interacting with a file Let's try to make some changes again to our <code>planets.csv</code> file. To begin, simply type <code>ed</code> followed by the file path: <pre><code>ed ./local-universe/milky-way/planets.csv\n</code></pre> <p>Output:</p> <pre><code>288\n</code></pre> <p>In this output, <code>ed</code> is telling us that it has read 288 characters into the editor buffer. Now, we can print out all of the lines of the file by running:</p> <pre><code>,p\n</code></pre> <p>Here, <code>,</code> is the line range address, and is equivalent to typing <code>1,$</code>, meaning \"from the first line to the last line\". The <code>p</code> then is the command: print the specified lines. Output:</p> <pre><code>Planet, Radius (km), Distance (AU), Mass (T),\nMercury, 2.44E3, 0.39, 3.29E20,\nVenus, 6.05E3, 0.72, 4.87E21,\nEarth, 6.37E3, 1, 5.97E21,\nMars, 3.39E3, 1.52, 6.42E20,\nJupiter, 7.15E4, 5.2, 1.90E24,\nSaturn, 6.03E4, 9.54, 5.69E23,\nUranus, 2.56E4, 19.2, 8.68E22,\nNeptune, 2.48E4, 30.1, 1.02E23\n</code></pre> <p>Now let's say we want to edit the file to change some of the Roman planet names to be their Greek counterparts and then print our changes. We can do this using similar commands to <code>sed</code>:</p> <pre><code>2s/Mercury/Hermes/\n3s/Venus/Aphrodite/\n5s/Mars/Ares/\n6s/Jupiter/Zeus/\n,p\n</code></pre> <p>Output:</p> <pre><code>Planet, Radius (km), Distance (AU), Mass (T),\nHermes, 2.44E3, 0.39, 3.29E20,\nAphrodite, 6.05E3, 0.72, 4.87E21,\nEarth, 6.37E3, 1, 5.97E21,\nAres, 3.39E3, 1.52, 6.42E20,\nZeus, 7.15E4, 5.2, 1.90E24,\nSaturn, 6.03E4, 9.54, 5.69E23,\nUranus, 2.56E4, 19.2, 8.68E22,\nNeptune, 2.48E4, 30.1, 1.02E23\n</code></pre> <p>Now let's say we want to make an addition to the file - let's add the dwarf planets Ceres and Pluto:</p> <pre><code>5a\nCeres, 469.7, 2.77, 9.3839E17\n.\nPluto, 1.19E3, 49.3, 1.3E19,\n</code></pre> <p>Let's also be sure to add a <code>,</code> to the end of Neptune's line:</p> <pre><code>10s/$/,/\n</code></pre> <p>Now we can check our work again by running <code>,p</code>:</p> <pre><code>Planet, Radius (km), Distance (AU), Mass (T),\nHermes, 2.44E3, 0.39, 3.29E20,\nAphrodite, 6.05E3, 0.72, 4.87E21,\nEarth, 6.37E3, 1, 5.97E21,\nAres, 3.39E3, 1.52, 6.42E20,\nCeres, 469.7, 2.77, 9.38E17,\nJupiter, 7.15E4, 5.2, 1.90E24,\nSaturn, 6.03E4, 9.54, 5.69E23,\nUranus, 2.56E4, 19.2, 8.68E22,\nNeptune, 2.48E4, 30.1, 1.02E23,\nPluto, 1.19E3, 49.3, 1.3E19,\n</code></pre> <p>Now we can save our work and exit <code>ed</code> by writing the changes to our file and quiting:</p> <pre><code>w\nq\n</code></pre> <p>Now that we have a basic understanding of using <code>sed</code> and <code>ed</code>, let's start putting all of our work together so that we can do some of what Unix is best at: scripting. Click here to continue on to the next section.</p>"},{"location":"09_shell_scripts/","title":"Shell Scripting","text":"<p>As the Unix shell is capable of using the contents of a file as input, it's possible to create a file with a list of commands which can then be executed by the shell. These files are called Shell Scripts or Shell Programs, and use the <code>.sh</code> file extension. Shell scripts work just like any other programming language, so having experience with other languages will make this section easier to understand. Creating shell scripts can be useful for many applications, such as:</p> <ul> <li> <p>Routing backups of files</p> </li> <li> <p>Adding new functionality to the shell</p> </li> <li> <p>Automating work and repitition, etc</p> </li> </ul> <p>Fortunately, the commands and syntax for shell scripting are the same as those entered directly in the command line, so this entire lesson so far can be applied directly in shell scripts.</p>"},{"location":"09_shell_scripts/#creating-your-first-shell-script","title":"Creating Your First Shell Script","text":"<p>To begin, create a file ending in <code>.sh</code>, such as <code>hello.sh</code>:</p> <pre><code>touch hello.sh\n</code></pre>"},{"location":"09_shell_scripts/#bash-bangshebang","title":"Bash Bang/Shebang","text":"<p>In order to tell the system to use the shell to interpret the commands, you'll have to start the file with a bash bang/shebang (a combination of <code>bash #</code> and <code>bang !</code>, followed by the bash shell path). </p> <p>The path can vary, so before we start working on our <code>.sh</code> file, you'll want to confirm the path to your bash shell with:</p> <pre><code>which bash\n</code></pre> <p>Output:</p> <pre><code>/usr/bin/bash\n</code></pre> <p>Now you can open your script with:</p> <pre><code>nano hello.sh\n</code></pre> <p>And add your shebang line along with some commands:</p> <pre><code>#! /usr/bin/bash\n\necho \"Hello, world!\"\ndate\n</code></pre> <p>You can then save and close the file.</p>"},{"location":"09_shell_scripts/#execution-rights","title":"Execution rights:","text":"<p>In order to be able to actually treat the file as an executable, you'll have to modify the file's permissions. Users are able to have read, write, or execute (<code>rwx</code>) rights for files. To add execution rights for this file, you can run:</p> <pre><code>chmod +x hello.sh\n</code></pre> <p>You should now be able to execute the file by running:</p> <pre><code>./hello.sh\n</code></pre> <p>Output:</p> <pre><code>Hello, world!\nWed Jul  2 18:19:48 MDT 2025\n</code></pre>"},{"location":"09_shell_scripts/#shell-scripting-syntax","title":"Shell Scripting Syntax","text":"<p>Like other programming languages, shell scripting allows for the definition of variables, user input, for and while loops, arithmetic expressions, logical operators, conditionals, and the reading of files. Let's take a look at some examples of each of these.</p>"},{"location":"09_shell_scripts/#variables","title":"Variables","text":"<p>Variables can be defined with <code>variable_name=value</code>. Note that bash does not allow for spaces between the variable name, equals sign, and the value. Then, to access the value of the variable in a later call, add <code>$</code> before the variable.</p> <p>Let's create a new file and start filling it with examples as we learn them:</p> <pre><code>nano examples.sh\n</code></pre> <pre><code>#! /usr/bin/bash\ngreeting=Hello\nuser=World\necho \"$greeting, $user!\"\n</code></pre> <p>You can then save this file and make it executable using the <code>chmod +x</code> command from before to give it a try.</p>"},{"location":"09_shell_scripts/#arithmetic","title":"Arithmetic","text":"<p>Bash supports the following operators for mathmatic arithmetic: | Operator | Use            | |---       |---             | | <code>**</code>     | Exponentiation | | <code>*</code>      | Multiplication | | <code>/</code>      | Division       | | <code>+</code>      | Addition       | | <code>-</code>      | Subtraction    | | <code>%</code>      | Modulus        | Storing expressions in variables uses the syntax of:</p> <pre><code>var=$((expression))\n</code></pre> <p>Let's try out some examples by setting some numbers to variables and performing some calculations. If you closed <code>examples.sh</code>, simply open it again with the <code>nano</code> command.</p> <pre><code>a=100\nb=5\nc=$((a / b))\necho $c\n</code></pre>"},{"location":"09_shell_scripts/#user-inputs","title":"User Inputs","text":"<p>It is possible to take user input using the <code>read</code> command. To prompt the user with a custom message for user input, you can pair <code>read</code> with the <code>-p</code> flag. </p>"},{"location":"09_shell_scripts/#conditionals","title":"Conditionals","text":""},{"location":"09_shell_scripts/#logical-operators","title":"Logical Operators","text":""},{"location":"09_shell_scripts/#reading-files","title":"Reading Files","text":""}]}